//Generated by ahl
#include "../TemporalAA.h"
#include <memory>
#include <Objects/Type.h>
#include <Objects/Serialize.h>
#include <Objects/SerializeSpecializations.h>
#include <Framework/Common/Log.h>
using namespace Ailu;
Ailu::Type* Ailu::Render::Z_Construct_TemporalAA_Type()
{
Ailu::Render::RenderFeature::StaticType();
static std::unique_ptr<Ailu::Type> cur_type = nullptr;
if(cur_type == nullptr)
{
TypeInitializer initializer;
initializer._name = "TemporalAA";
initializer._size = sizeof(Ailu::Render::TemporalAA);
initializer._full_name = "Ailu::Render::TemporalAA";
initializer._is_class = true;
initializer._is_abstract = false;
initializer._namespace = "Ailu::Render";
initializer._base_name = "Ailu::Render::RenderFeature";
initializer._constructor = []()->Ailu::Render::TemporalAA* {return new Ailu::Render::TemporalAA;};
Meta meta_history_factor;
meta_history_factor.Set("Category","");
meta_history_factor.Set("IsColor",false);
meta_history_factor.Set("IsRange",true);
meta_history_factor.Set("IsFloatRange",true);
meta_history_factor.Set("RangeMin",0);
meta_history_factor.Set("RangeMax",1);
MemberBuilder builder_history_factor;
builder_history_factor._name = "_history_factor";
builder_history_factor._type_name = "f32";
builder_history_factor._offset = offsetof(TemporalAA,_history_factor);
builder_history_factor._is_const = false;
builder_history_factor._is_static = false;
builder_history_factor._is_public = true;
builder_history_factor._is_pointer = false;
builder_history_factor._is_ref = false;
builder_history_factor._is_template = false;
builder_history_factor._meta = meta_history_factor;
builder_history_factor._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<f32>);
builder_history_factor._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<f32>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_history_factor));
Meta meta_jitter_scale;
meta_jitter_scale.Set("Category","");
meta_jitter_scale.Set("IsColor",false);
meta_jitter_scale.Set("IsRange",true);
meta_jitter_scale.Set("IsFloatRange",true);
meta_jitter_scale.Set("RangeMin",0);
meta_jitter_scale.Set("RangeMax",1);
MemberBuilder builder_jitter_scale;
builder_jitter_scale._name = "_jitter_scale";
builder_jitter_scale._type_name = "f32";
builder_jitter_scale._offset = offsetof(TemporalAA,_jitter_scale);
builder_jitter_scale._is_const = false;
builder_jitter_scale._is_static = false;
builder_jitter_scale._is_public = true;
builder_jitter_scale._is_pointer = false;
builder_jitter_scale._is_ref = false;
builder_jitter_scale._is_template = false;
builder_jitter_scale._meta = meta_jitter_scale;
builder_jitter_scale._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<f32>);
builder_jitter_scale._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<f32>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_jitter_scale));
Meta meta_clamp_quality;
meta_clamp_quality.Set("Category","");
meta_clamp_quality.Set("IsColor",false);
meta_clamp_quality.Set("IsRange",true);
meta_clamp_quality.Set("IsFloatRange",true);
meta_clamp_quality.Set("RangeMin",0);
meta_clamp_quality.Set("RangeMax",2);
MemberBuilder builder_clamp_quality;
builder_clamp_quality._name = "_clamp_quality";
builder_clamp_quality._type_name = "f32";
builder_clamp_quality._offset = offsetof(TemporalAA,_clamp_quality);
builder_clamp_quality._is_const = false;
builder_clamp_quality._is_static = false;
builder_clamp_quality._is_public = true;
builder_clamp_quality._is_pointer = false;
builder_clamp_quality._is_ref = false;
builder_clamp_quality._is_template = false;
builder_clamp_quality._meta = meta_clamp_quality;
builder_clamp_quality._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<f32>);
builder_clamp_quality._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<f32>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_clamp_quality));
Meta meta_history_quality;
meta_history_quality.Set("Category","");
meta_history_quality.Set("IsColor",false);
meta_history_quality.Set("IsRange",true);
meta_history_quality.Set("IsFloatRange",true);
meta_history_quality.Set("RangeMin",0);
meta_history_quality.Set("RangeMax",2);
MemberBuilder builder_history_quality;
builder_history_quality._name = "_history_quality";
builder_history_quality._type_name = "f32";
builder_history_quality._offset = offsetof(TemporalAA,_history_quality);
builder_history_quality._is_const = false;
builder_history_quality._is_static = false;
builder_history_quality._is_public = true;
builder_history_quality._is_pointer = false;
builder_history_quality._is_ref = false;
builder_history_quality._is_template = false;
builder_history_quality._meta = meta_history_quality;
builder_history_quality._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<f32>);
builder_history_quality._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<f32>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_history_quality));
Meta meta_motion_quality;
meta_motion_quality.Set("Category","");
meta_motion_quality.Set("IsColor",false);
meta_motion_quality.Set("IsRange",true);
meta_motion_quality.Set("IsFloatRange",true);
meta_motion_quality.Set("RangeMin",0);
meta_motion_quality.Set("RangeMax",2);
MemberBuilder builder_motion_quality;
builder_motion_quality._name = "_motion_quality";
builder_motion_quality._type_name = "f32";
builder_motion_quality._offset = offsetof(TemporalAA,_motion_quality);
builder_motion_quality._is_const = false;
builder_motion_quality._is_static = false;
builder_motion_quality._is_public = true;
builder_motion_quality._is_pointer = false;
builder_motion_quality._is_ref = false;
builder_motion_quality._is_template = false;
builder_motion_quality._meta = meta_motion_quality;
builder_motion_quality._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<f32>);
builder_motion_quality._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<f32>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_motion_quality));
Meta meta_variance_clip_scale;
meta_variance_clip_scale.Set("Category","");
meta_variance_clip_scale.Set("IsColor",false);
meta_variance_clip_scale.Set("IsRange",true);
meta_variance_clip_scale.Set("IsFloatRange",true);
meta_variance_clip_scale.Set("RangeMin",0);
meta_variance_clip_scale.Set("RangeMax",2);
MemberBuilder builder_variance_clip_scale;
builder_variance_clip_scale._name = "_variance_clip_scale";
builder_variance_clip_scale._type_name = "f32";
builder_variance_clip_scale._offset = offsetof(TemporalAA,_variance_clip_scale);
builder_variance_clip_scale._is_const = false;
builder_variance_clip_scale._is_static = false;
builder_variance_clip_scale._is_public = true;
builder_variance_clip_scale._is_pointer = false;
builder_variance_clip_scale._is_ref = false;
builder_variance_clip_scale._is_template = false;
builder_variance_clip_scale._meta = meta_variance_clip_scale;
builder_variance_clip_scale._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<f32>);
builder_variance_clip_scale._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<f32>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_variance_clip_scale));
Meta meta_sharpness;
meta_sharpness.Set("Category","");
meta_sharpness.Set("IsColor",false);
meta_sharpness.Set("IsRange",true);
meta_sharpness.Set("IsFloatRange",true);
meta_sharpness.Set("RangeMin",0);
meta_sharpness.Set("RangeMax",4);
MemberBuilder builder_sharpness;
builder_sharpness._name = "_sharpness";
builder_sharpness._type_name = "f32";
builder_sharpness._offset = offsetof(TemporalAA,_sharpness);
builder_sharpness._is_const = false;
builder_sharpness._is_static = false;
builder_sharpness._is_public = true;
builder_sharpness._is_pointer = false;
builder_sharpness._is_ref = false;
builder_sharpness._is_template = false;
builder_sharpness._meta = meta_sharpness;
builder_sharpness._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<f32>);
builder_sharpness._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<f32>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_sharpness));
cur_type = std::make_unique<Ailu::Type>(initializer);
Ailu::Type::RegisterType(cur_type.get());
}
return cur_type.get();
}

Ailu::Type* Ailu::Render::TemporalAA::GetPrivateStaticClass()
{
	static Ailu::Type* type = Z_Construct_TemporalAA_Type();
	return type;
}

template<> Ailu::Type* Ailu::StaticClass<Ailu::Render::TemporalAA>()
{
return Ailu::Render::TemporalAA::StaticType();
}
    Type *Ailu::Render::TemporalAA::GetType()
{
return Ailu::Render::TemporalAA::GetPrivateStaticClass();
}
ClassTypeRegister s_register_TemporalAA(&Ailu::Render::TemporalAA::StaticType, "Ailu::Render::TemporalAA");

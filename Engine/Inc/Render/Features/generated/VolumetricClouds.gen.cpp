//Generated by ahl
#include "../VolumetricClouds.h"
#include <memory>
#include <Objects/Type.h>
#include <Objects/Serialize.h>
#include <Objects/SerializeSpecializations.h>
#include <Framework/Common/Log.h>
using namespace Ailu;
Ailu::Type* Ailu::Render::Z_Construct_VolumetricClouds_Type()
{
Ailu::Render::RenderFeature::StaticType();
static std::unique_ptr<Ailu::Type> cur_type = nullptr;
if(cur_type == nullptr)
{
TypeInitializer initializer;
initializer._name = "VolumetricClouds";
initializer._size = sizeof(Ailu::Render::VolumetricClouds);
initializer._full_name = "Ailu::Render::VolumetricClouds";
initializer._is_class = true;
initializer._is_abstract = false;
initializer._namespace = "Ailu::Render";
initializer._base_name = "Ailu::Render::RenderFeature";
initializer._constructor = []()->Ailu::Render::VolumetricClouds* {return new Ailu::Render::VolumetricClouds;};
Meta meta_is_tile_render;
meta_is_tile_render.Set("Category","Base");
meta_is_tile_render.Set("IsColor",false);
meta_is_tile_render.Set("IsRange",false);
meta_is_tile_render.Set("IsFloatRange",true);
meta_is_tile_render.Set("RangeMin",0);
meta_is_tile_render.Set("RangeMax",1);
MemberBuilder builder_is_tile_render;
builder_is_tile_render._name = "_is_tile_render";
builder_is_tile_render._type_name = "bool";
builder_is_tile_render._offset = offsetof(VolumetricClouds,_is_tile_render);
builder_is_tile_render._is_const = false;
builder_is_tile_render._is_static = false;
builder_is_tile_render._is_public = true;
builder_is_tile_render._is_pointer = false;
builder_is_tile_render._is_ref = false;
builder_is_tile_render._is_template = false;
builder_is_tile_render._meta = meta_is_tile_render;
builder_is_tile_render._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<bool>);
builder_is_tile_render._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<bool>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_is_tile_render));
Meta meta_is_high_quality;
meta_is_high_quality.Set("Category","Base");
meta_is_high_quality.Set("IsColor",false);
meta_is_high_quality.Set("IsRange",false);
meta_is_high_quality.Set("IsFloatRange",true);
meta_is_high_quality.Set("RangeMin",0);
meta_is_high_quality.Set("RangeMax",1);
MemberBuilder builder_is_high_quality;
builder_is_high_quality._name = "_is_high_quality";
builder_is_high_quality._type_name = "bool";
builder_is_high_quality._offset = offsetof(VolumetricClouds,_is_high_quality);
builder_is_high_quality._is_const = false;
builder_is_high_quality._is_static = false;
builder_is_high_quality._is_public = true;
builder_is_high_quality._is_pointer = false;
builder_is_high_quality._is_ref = false;
builder_is_high_quality._is_template = false;
builder_is_high_quality._meta = meta_is_high_quality;
builder_is_high_quality._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<bool>);
builder_is_high_quality._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<bool>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_is_high_quality));
Meta meta_height;
meta_height.Set("Category","Base");
meta_height.Set("IsColor",false);
meta_height.Set("IsRange",true);
meta_height.Set("IsFloatRange",true);
meta_height.Set("RangeMin",0);
meta_height.Set("RangeMax",10000);
MemberBuilder builder_height;
builder_height._name = "_height";
builder_height._type_name = "f32";
builder_height._offset = offsetof(VolumetricClouds,_height);
builder_height._is_const = false;
builder_height._is_static = false;
builder_height._is_public = true;
builder_height._is_pointer = false;
builder_height._is_ref = false;
builder_height._is_template = false;
builder_height._meta = meta_height;
builder_height._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<f32>);
builder_height._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<f32>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_height));
Meta meta_thickness;
meta_thickness.Set("Category","Base");
meta_thickness.Set("IsColor",false);
meta_thickness.Set("IsRange",true);
meta_thickness.Set("IsFloatRange",true);
meta_thickness.Set("RangeMin",100);
meta_thickness.Set("RangeMax",10000);
MemberBuilder builder_thickness;
builder_thickness._name = "_thickness";
builder_thickness._type_name = "f32";
builder_thickness._offset = offsetof(VolumetricClouds,_thickness);
builder_thickness._is_const = false;
builder_thickness._is_static = false;
builder_thickness._is_public = true;
builder_thickness._is_pointer = false;
builder_thickness._is_ref = false;
builder_thickness._is_template = false;
builder_thickness._meta = meta_thickness;
builder_thickness._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<f32>);
builder_thickness._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<f32>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_thickness));
Meta meta_absorbtion;
meta_absorbtion.Set("Category","Base");
meta_absorbtion.Set("IsColor",true);
meta_absorbtion.Set("IsRange",false);
meta_absorbtion.Set("IsFloatRange",true);
meta_absorbtion.Set("RangeMin",0);
meta_absorbtion.Set("RangeMax",1);
MemberBuilder builder_absorbtion;
builder_absorbtion._name = "_absorbtion";
builder_absorbtion._type_name = "Color";
builder_absorbtion._offset = offsetof(VolumetricClouds,_absorbtion);
builder_absorbtion._is_const = false;
builder_absorbtion._is_static = false;
builder_absorbtion._is_public = true;
builder_absorbtion._is_pointer = false;
builder_absorbtion._is_ref = false;
builder_absorbtion._is_template = false;
builder_absorbtion._meta = meta_absorbtion;
builder_absorbtion._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<Color>);
builder_absorbtion._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<Color>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_absorbtion));
Meta meta_scattering;
meta_scattering.Set("Category","Base");
meta_scattering.Set("IsColor",true);
meta_scattering.Set("IsRange",false);
meta_scattering.Set("IsFloatRange",true);
meta_scattering.Set("RangeMin",0);
meta_scattering.Set("RangeMax",1);
MemberBuilder builder_scattering;
builder_scattering._name = "_scattering";
builder_scattering._type_name = "Color";
builder_scattering._offset = offsetof(VolumetricClouds,_scattering);
builder_scattering._is_const = false;
builder_scattering._is_static = false;
builder_scattering._is_public = true;
builder_scattering._is_pointer = false;
builder_scattering._is_ref = false;
builder_scattering._is_template = false;
builder_scattering._meta = meta_scattering;
builder_scattering._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<Color>);
builder_scattering._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<Color>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_scattering));
Meta meta_speed;
meta_speed.Set("Category","Base");
meta_speed.Set("IsColor",false);
meta_speed.Set("IsRange",true);
meta_speed.Set("IsFloatRange",true);
meta_speed.Set("RangeMin",0);
meta_speed.Set("RangeMax",50);
MemberBuilder builder_speed;
builder_speed._name = "_speed";
builder_speed._type_name = "f32";
builder_speed._offset = offsetof(VolumetricClouds,_speed);
builder_speed._is_const = false;
builder_speed._is_static = false;
builder_speed._is_public = true;
builder_speed._is_pointer = false;
builder_speed._is_ref = false;
builder_speed._is_template = false;
builder_speed._meta = meta_speed;
builder_speed._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<f32>);
builder_speed._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<f32>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_speed));
Meta meta_exposure;
meta_exposure.Set("Category","Base");
meta_exposure.Set("IsColor",false);
meta_exposure.Set("IsRange",true);
meta_exposure.Set("IsFloatRange",true);
meta_exposure.Set("RangeMin",0);
meta_exposure.Set("RangeMax",10);
MemberBuilder builder_exposure;
builder_exposure._name = "_exposure";
builder_exposure._type_name = "f32";
builder_exposure._offset = offsetof(VolumetricClouds,_exposure);
builder_exposure._is_const = false;
builder_exposure._is_static = false;
builder_exposure._is_public = true;
builder_exposure._is_pointer = false;
builder_exposure._is_ref = false;
builder_exposure._is_template = false;
builder_exposure._meta = meta_exposure;
builder_exposure._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<f32>);
builder_exposure._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<f32>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_exposure));
Meta meta_type_offset;
meta_type_offset.Set("Category","Base");
meta_type_offset.Set("IsColor",false);
meta_type_offset.Set("IsRange",true);
meta_type_offset.Set("IsFloatRange",true);
meta_type_offset.Set("RangeMin",-1);
meta_type_offset.Set("RangeMax",1);
MemberBuilder builder_type_offset;
builder_type_offset._name = "_type_offset";
builder_type_offset._type_name = "f32";
builder_type_offset._offset = offsetof(VolumetricClouds,_type_offset);
builder_type_offset._is_const = false;
builder_type_offset._is_static = false;
builder_type_offset._is_public = true;
builder_type_offset._is_pointer = false;
builder_type_offset._is_ref = false;
builder_type_offset._is_template = false;
builder_type_offset._meta = meta_type_offset;
builder_type_offset._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<f32>);
builder_type_offset._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<f32>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_type_offset));
Meta meta_density_multiplier;
meta_density_multiplier.Set("Category","Base");
meta_density_multiplier.Set("IsColor",false);
meta_density_multiplier.Set("IsRange",true);
meta_density_multiplier.Set("IsFloatRange",true);
meta_density_multiplier.Set("RangeMin",0);
meta_density_multiplier.Set("RangeMax",4);
MemberBuilder builder_density_multiplier;
builder_density_multiplier._name = "_density_multiplier";
builder_density_multiplier._type_name = "f32";
builder_density_multiplier._offset = offsetof(VolumetricClouds,_density_multiplier);
builder_density_multiplier._is_const = false;
builder_density_multiplier._is_static = false;
builder_density_multiplier._is_public = true;
builder_density_multiplier._is_pointer = false;
builder_density_multiplier._is_ref = false;
builder_density_multiplier._is_template = false;
builder_density_multiplier._meta = meta_density_multiplier;
builder_density_multiplier._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<f32>);
builder_density_multiplier._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<f32>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_density_multiplier));
Meta meta_threshold;
meta_threshold.Set("Category","Base");
meta_threshold.Set("IsColor",false);
meta_threshold.Set("IsRange",true);
meta_threshold.Set("IsFloatRange",true);
meta_threshold.Set("RangeMin",0);
meta_threshold.Set("RangeMax",1);
MemberBuilder builder_threshold;
builder_threshold._name = "_threshold";
builder_threshold._type_name = "f32";
builder_threshold._offset = offsetof(VolumetricClouds,_threshold);
builder_threshold._is_const = false;
builder_threshold._is_static = false;
builder_threshold._is_public = true;
builder_threshold._is_pointer = false;
builder_threshold._is_ref = false;
builder_threshold._is_template = false;
builder_threshold._meta = meta_threshold;
builder_threshold._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<f32>);
builder_threshold._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<f32>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_threshold));
cur_type = std::make_unique<Ailu::Type>(initializer);
Ailu::Type::RegisterType(cur_type.get());
}
return cur_type.get();
}

Ailu::Type* Ailu::Render::VolumetricClouds::GetPrivateStaticClass()
{
	static Ailu::Type* type = Z_Construct_VolumetricClouds_Type();
	return type;
}

template<> Ailu::Type* Ailu::StaticClass<Ailu::Render::VolumetricClouds>()
{
return Ailu::Render::VolumetricClouds::StaticType();
}
    Type *Ailu::Render::VolumetricClouds::GetType()
{
return Ailu::Render::VolumetricClouds::GetPrivateStaticClass();
}
ClassTypeRegister s_register_VolumetricClouds(&Ailu::Render::VolumetricClouds::StaticType, "Ailu::Render::VolumetricClouds");

//Generated by ahl
#include "../PostprocessPass.h"
#include <memory>
#include <Objects/Type.h>
#include <Objects/Serialize.h>
#include <Objects/SerializeSpecializations.h>
#include <Framework/Common/Log.h>
using namespace Ailu;
const Ailu::Type* Ailu::Render::Z_Construct_PostProcessPass_Type()
{
static std::unique_ptr<Ailu::Type> cur_type = nullptr;
if(cur_type == nullptr)
{
TypeInitializer initializer;
initializer._name = "PostProcessPass";
initializer._size = sizeof(Ailu::Render::PostProcessPass);
initializer._full_name = "Ailu::Render::PostProcessPass";
initializer._is_class = true;
initializer._is_abstract = false;
initializer._namespace = "Ailu::Render";
initializer._base_name = "Ailu::Render::RenderPass";
Meta meta_upsample_radius;
meta_upsample_radius._category="";
meta_upsample_radius._min=(float)0;
meta_upsample_radius._max=(float)1;
meta_upsample_radius._is_range=false;
meta_upsample_radius._is_float_range=true;
meta_upsample_radius._is_color=false;
MemberInfoInitializer initializer__upsample_radius = {EMemberType::kProperty, "_upsample_radius", "f32", offsetof(PostProcessPass,_upsample_radius), &PostProcessPass::_upsample_radius, meta_upsample_radius, false, true, false, false, false, false, nullptr, nullptr};
initializer__upsample_radius._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<f32>);
initializer__upsample_radius._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<f32>);
initializer__upsample_radius._type = Ailu::Type::Find("f32");
initializer._properties.emplace_back(initializer__upsample_radius);
Meta meta_bloom_intensity;
meta_bloom_intensity._category="";
meta_bloom_intensity._min=(float)0;
meta_bloom_intensity._max=(float)1;
meta_bloom_intensity._is_range=false;
meta_bloom_intensity._is_float_range=true;
meta_bloom_intensity._is_color=false;
MemberInfoInitializer initializer__bloom_intensity = {EMemberType::kProperty, "_bloom_intensity", "f32", offsetof(PostProcessPass,_bloom_intensity), &PostProcessPass::_bloom_intensity, meta_bloom_intensity, false, true, false, false, false, false, nullptr, nullptr};
initializer__bloom_intensity._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<f32>);
initializer__bloom_intensity._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<f32>);
initializer__bloom_intensity._type = Ailu::Type::Find("f32");
initializer._properties.emplace_back(initializer__bloom_intensity);
Meta meta_is_use_blur;
meta_is_use_blur._category="";
meta_is_use_blur._min=(float)0;
meta_is_use_blur._max=(float)1;
meta_is_use_blur._is_range=false;
meta_is_use_blur._is_float_range=true;
meta_is_use_blur._is_color=false;
MemberInfoInitializer initializer__is_use_blur = {EMemberType::kProperty, "_is_use_blur", "bool", offsetof(PostProcessPass,_is_use_blur), &PostProcessPass::_is_use_blur, meta_is_use_blur, false, true, false, false, false, false, nullptr, nullptr};
initializer__is_use_blur._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<bool>);
initializer__is_use_blur._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<bool>);
initializer__is_use_blur._type = Ailu::Type::Find("bool");
initializer._properties.emplace_back(initializer__is_use_blur);
cur_type = std::make_unique<Ailu::Type>(initializer);
Ailu::Type::RegisterType(cur_type.get());
}
return cur_type.get();
}

const Ailu::Type* Ailu::Render::PostProcessPass::GetPrivateStaticClass()
{
	static const Ailu::Type* type = Z_Construct_PostProcessPass_Type();
	return type;
}

template<> const Ailu::Type* Ailu::StaticClass<Ailu::Render::PostProcessPass>()
{
return Ailu::Render::PostProcessPass::StaticType();
}
    const Type *Ailu::Render::PostProcessPass::GetType() const
{
return Ailu::Render::PostProcessPass::GetPrivateStaticClass();
}

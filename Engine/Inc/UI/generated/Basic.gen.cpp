//Generated by ahl
#include "../Basic.h"
#include <memory>
#include <Objects/Type.h>
#include <Objects/Serialize.h>
#include <Objects/SerializeSpecializations.h>
#include <Framework/Common/Log.h>
using namespace Ailu;
Ailu::Type* Ailu::UI::Z_Construct_Button_Type()
{
Ailu::UI::UIElement::StaticType();
static std::unique_ptr<Ailu::Type> cur_type = nullptr;
if(cur_type == nullptr)
{
TypeInitializer initializer;
initializer._name = "Button";
initializer._size = sizeof(Ailu::UI::Button);
initializer._full_name = "Ailu::UI::Button";
initializer._is_class = true;
initializer._is_abstract = false;
initializer._namespace = "Ailu::UI";
initializer._base_name = "Ailu::UI::UIElement";
initializer._constructor = []()->Ailu::UI::Button* {return new Ailu::UI::Button;};
cur_type = std::make_unique<Ailu::Type>(initializer);
Ailu::Type::RegisterType(cur_type.get());
}
return cur_type.get();
}

Ailu::Type* Ailu::UI::Button::GetPrivateStaticClass()
{
	static Ailu::Type* type = Z_Construct_Button_Type();
	return type;
}

template<> Ailu::Type* Ailu::StaticClass<Ailu::UI::Button>()
{
return Ailu::UI::Button::StaticType();
}
    Type *Ailu::UI::Button::GetType()
{
return Ailu::UI::Button::GetPrivateStaticClass();
}
ClassTypeRegister s_register_Button(&Ailu::UI::Button::StaticType, "Ailu::UI::Button");
Ailu::Type* Ailu::UI::Z_Construct_Text_Type()
{
Ailu::UI::UIElement::StaticType();
static std::unique_ptr<Ailu::Type> cur_type = nullptr;
if(cur_type == nullptr)
{
TypeInitializer initializer;
initializer._name = "Text";
initializer._size = sizeof(Ailu::UI::Text);
initializer._full_name = "Ailu::UI::Text";
initializer._is_class = true;
initializer._is_abstract = false;
initializer._namespace = "Ailu::UI";
initializer._base_name = "Ailu::UI::UIElement";
initializer._constructor = []()->Ailu::UI::Text* {return new Ailu::UI::Text;};
Meta meta_text;
meta_text.Set("Category","");
meta_text.Set("IsColor",false);
meta_text.Set("IsRange",false);
meta_text.Set("IsFloatRange",true);
meta_text.Set("RangeMin",0);
meta_text.Set("RangeMax",1);
MemberBuilder builder_text;
builder_text._name = "_text";
builder_text._type_name = "String";
builder_text._offset = offsetof(Text,_text);
builder_text._is_const = false;
builder_text._is_static = false;
builder_text._is_public = true;
builder_text._is_pointer = false;
builder_text._is_ref = false;
builder_text._is_template = false;
builder_text._meta = meta_text;
builder_text._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<String>);
builder_text._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<String>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_text));
Meta meta_font_size;
meta_font_size.Set("Category","");
meta_font_size.Set("IsColor",false);
meta_font_size.Set("IsRange",false);
meta_font_size.Set("IsFloatRange",true);
meta_font_size.Set("RangeMin",0);
meta_font_size.Set("RangeMax",1);
MemberBuilder builder_font_size;
builder_font_size._name = "_font_size";
builder_font_size._type_name = "u16";
builder_font_size._offset = offsetof(Text,_font_size);
builder_font_size._is_const = false;
builder_font_size._is_static = false;
builder_font_size._is_public = true;
builder_font_size._is_pointer = false;
builder_font_size._is_ref = false;
builder_font_size._is_template = false;
builder_font_size._meta = meta_font_size;
builder_font_size._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<u16>);
builder_font_size._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<u16>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_font_size));
Meta meta_color;
meta_color.Set("Category","");
meta_color.Set("IsColor",true);
meta_color.Set("IsRange",false);
meta_color.Set("IsFloatRange",true);
meta_color.Set("RangeMin",0);
meta_color.Set("RangeMax",1);
MemberBuilder builder_color;
builder_color._name = "_color";
builder_color._type_name = "Color";
builder_color._offset = offsetof(Text,_color);
builder_color._is_const = false;
builder_color._is_static = false;
builder_color._is_public = true;
builder_color._is_pointer = false;
builder_color._is_ref = false;
builder_color._is_template = false;
builder_color._meta = meta_color;
builder_color._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<Color>);
builder_color._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<Color>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_color));
cur_type = std::make_unique<Ailu::Type>(initializer);
Ailu::Type::RegisterType(cur_type.get());
}
return cur_type.get();
}

Ailu::Type* Ailu::UI::Text::GetPrivateStaticClass()
{
	static Ailu::Type* type = Z_Construct_Text_Type();
	return type;
}

template<> Ailu::Type* Ailu::StaticClass<Ailu::UI::Text>()
{
return Ailu::UI::Text::StaticType();
}
    Type *Ailu::UI::Text::GetType()
{
return Ailu::UI::Text::GetPrivateStaticClass();
}
ClassTypeRegister s_register_Text(&Ailu::UI::Text::StaticType, "Ailu::UI::Text");
Ailu::Type* Ailu::UI::Z_Construct_Slider_Type()
{
Ailu::UI::UIElement::StaticType();
static std::unique_ptr<Ailu::Type> cur_type = nullptr;
if(cur_type == nullptr)
{
TypeInitializer initializer;
initializer._name = "Slider";
initializer._size = sizeof(Ailu::UI::Slider);
initializer._full_name = "Ailu::UI::Slider";
initializer._is_class = true;
initializer._is_abstract = false;
initializer._namespace = "Ailu::UI";
initializer._base_name = "Ailu::UI::UIElement";
initializer._constructor = []()->Ailu::UI::Slider* {return new Ailu::UI::Slider;};
Meta meta_range;
meta_range.Set("Category","");
meta_range.Set("IsColor",false);
meta_range.Set("IsRange",false);
meta_range.Set("IsFloatRange",true);
meta_range.Set("RangeMin",0);
meta_range.Set("RangeMax",1);
MemberBuilder builder_range;
builder_range._name = "_range";
builder_range._type_name = "Vector2f";
builder_range._offset = offsetof(Slider,_range);
builder_range._is_const = false;
builder_range._is_static = false;
builder_range._is_public = true;
builder_range._is_pointer = false;
builder_range._is_ref = false;
builder_range._is_template = false;
builder_range._meta = meta_range;
builder_range._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<Vector2f>);
builder_range._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<Vector2f>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_range));
Meta meta_value;
meta_value.Set("Category","");
meta_value.Set("IsColor",false);
meta_value.Set("IsRange",false);
meta_value.Set("IsFloatRange",true);
meta_value.Set("RangeMin",0);
meta_value.Set("RangeMax",1);
MemberBuilder builder_value;
builder_value._name = "_value";
builder_value._type_name = "f32";
builder_value._offset = offsetof(Slider,_value);
builder_value._is_const = false;
builder_value._is_static = false;
builder_value._is_public = true;
builder_value._is_pointer = false;
builder_value._is_ref = false;
builder_value._is_template = false;
builder_value._meta = meta_value;
builder_value._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<f32>);
builder_value._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<f32>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_value));
Meta meta_font_size;
meta_font_size.Set("Category","");
meta_font_size.Set("IsColor",false);
meta_font_size.Set("IsRange",false);
meta_font_size.Set("IsFloatRange",true);
meta_font_size.Set("RangeMin",0);
meta_font_size.Set("RangeMax",1);
MemberBuilder builder_font_size;
builder_font_size._name = "_font_size";
builder_font_size._type_name = "u32";
builder_font_size._offset = offsetof(Slider,_font_size);
builder_font_size._is_const = false;
builder_font_size._is_static = false;
builder_font_size._is_public = true;
builder_font_size._is_pointer = false;
builder_font_size._is_ref = false;
builder_font_size._is_template = false;
builder_font_size._meta = meta_font_size;
builder_font_size._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<u32>);
builder_font_size._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<u32>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_font_size));
cur_type = std::make_unique<Ailu::Type>(initializer);
Ailu::Type::RegisterType(cur_type.get());
}
return cur_type.get();
}

Ailu::Type* Ailu::UI::Slider::GetPrivateStaticClass()
{
	static Ailu::Type* type = Z_Construct_Slider_Type();
	return type;
}

template<> Ailu::Type* Ailu::StaticClass<Ailu::UI::Slider>()
{
return Ailu::UI::Slider::StaticType();
}
    Type *Ailu::UI::Slider::GetType()
{
return Ailu::UI::Slider::GetPrivateStaticClass();
}
ClassTypeRegister s_register_Slider(&Ailu::UI::Slider::StaticType, "Ailu::UI::Slider");
Ailu::Type* Ailu::UI::Z_Construct_CheckBox_Type()
{
Ailu::UI::UIElement::StaticType();
static std::unique_ptr<Ailu::Type> cur_type = nullptr;
if(cur_type == nullptr)
{
TypeInitializer initializer;
initializer._name = "CheckBox";
initializer._size = sizeof(Ailu::UI::CheckBox);
initializer._full_name = "Ailu::UI::CheckBox";
initializer._is_class = true;
initializer._is_abstract = false;
initializer._namespace = "Ailu::UI";
initializer._base_name = "Ailu::UI::UIElement";
initializer._constructor = []()->Ailu::UI::CheckBox* {return new Ailu::UI::CheckBox;};
Meta meta_is_checked;
meta_is_checked.Set("Category","");
meta_is_checked.Set("IsColor",false);
meta_is_checked.Set("IsRange",false);
meta_is_checked.Set("IsFloatRange",true);
meta_is_checked.Set("RangeMin",0);
meta_is_checked.Set("RangeMax",1);
MemberBuilder builder_is_checked;
builder_is_checked._name = "_is_checked";
builder_is_checked._type_name = "bool";
builder_is_checked._offset = offsetof(CheckBox,_is_checked);
builder_is_checked._is_const = false;
builder_is_checked._is_static = false;
builder_is_checked._is_public = true;
builder_is_checked._is_pointer = false;
builder_is_checked._is_ref = false;
builder_is_checked._is_template = false;
builder_is_checked._meta = meta_is_checked;
builder_is_checked._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<bool>);
builder_is_checked._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<bool>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_is_checked));
cur_type = std::make_unique<Ailu::Type>(initializer);
Ailu::Type::RegisterType(cur_type.get());
}
return cur_type.get();
}

Ailu::Type* Ailu::UI::CheckBox::GetPrivateStaticClass()
{
	static Ailu::Type* type = Z_Construct_CheckBox_Type();
	return type;
}

template<> Ailu::Type* Ailu::StaticClass<Ailu::UI::CheckBox>()
{
return Ailu::UI::CheckBox::StaticType();
}
    Type *Ailu::UI::CheckBox::GetType()
{
return Ailu::UI::CheckBox::GetPrivateStaticClass();
}
ClassTypeRegister s_register_CheckBox(&Ailu::UI::CheckBox::StaticType, "Ailu::UI::CheckBox");
Ailu::Type* Ailu::UI::Z_Construct_Border_Type()
{
Ailu::UI::UIElement::StaticType();
static std::unique_ptr<Ailu::Type> cur_type = nullptr;
if(cur_type == nullptr)
{
TypeInitializer initializer;
initializer._name = "Border";
initializer._size = sizeof(Ailu::UI::Border);
initializer._full_name = "Ailu::UI::Border";
initializer._is_class = true;
initializer._is_abstract = false;
initializer._namespace = "Ailu::UI";
initializer._base_name = "Ailu::UI::UIElement";
initializer._constructor = []()->Ailu::UI::Border* {return new Ailu::UI::Border;};
Meta meta_bg_color;
meta_bg_color.Set("Category","");
meta_bg_color.Set("IsColor",true);
meta_bg_color.Set("IsRange",false);
meta_bg_color.Set("IsFloatRange",true);
meta_bg_color.Set("RangeMin",0);
meta_bg_color.Set("RangeMax",1);
MemberBuilder builder_bg_color;
builder_bg_color._name = "_bg_color";
builder_bg_color._type_name = "Color";
builder_bg_color._offset = offsetof(Border,_bg_color);
builder_bg_color._is_const = false;
builder_bg_color._is_static = false;
builder_bg_color._is_public = true;
builder_bg_color._is_pointer = false;
builder_bg_color._is_ref = false;
builder_bg_color._is_template = false;
builder_bg_color._meta = meta_bg_color;
builder_bg_color._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<Color>);
builder_bg_color._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<Color>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_bg_color));
Meta meta_border_color;
meta_border_color.Set("Category","");
meta_border_color.Set("IsColor",true);
meta_border_color.Set("IsRange",false);
meta_border_color.Set("IsFloatRange",true);
meta_border_color.Set("RangeMin",0);
meta_border_color.Set("RangeMax",1);
MemberBuilder builder_border_color;
builder_border_color._name = "_border_color";
builder_border_color._type_name = "Color";
builder_border_color._offset = offsetof(Border,_border_color);
builder_border_color._is_const = false;
builder_border_color._is_static = false;
builder_border_color._is_public = true;
builder_border_color._is_pointer = false;
builder_border_color._is_ref = false;
builder_border_color._is_template = false;
builder_border_color._meta = meta_border_color;
builder_border_color._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<Color>);
builder_border_color._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<Color>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_border_color));
Meta meta_thickness;
meta_thickness.Set("Category","");
meta_thickness.Set("IsColor",false);
meta_thickness.Set("IsRange",false);
meta_thickness.Set("IsFloatRange",true);
meta_thickness.Set("RangeMin",0);
meta_thickness.Set("RangeMax",1);
MemberBuilder builder_thickness;
builder_thickness._name = "_thickness";
builder_thickness._type_name = "f32";
builder_thickness._offset = offsetof(Border,_thickness);
builder_thickness._is_const = false;
builder_thickness._is_static = false;
builder_thickness._is_public = true;
builder_thickness._is_pointer = false;
builder_thickness._is_ref = false;
builder_thickness._is_template = false;
builder_thickness._meta = meta_thickness;
builder_thickness._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<f32>);
builder_thickness._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<f32>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_thickness));
cur_type = std::make_unique<Ailu::Type>(initializer);
Ailu::Type::RegisterType(cur_type.get());
}
return cur_type.get();
}

Ailu::Type* Ailu::UI::Border::GetPrivateStaticClass()
{
	static Ailu::Type* type = Z_Construct_Border_Type();
	return type;
}

template<> Ailu::Type* Ailu::StaticClass<Ailu::UI::Border>()
{
return Ailu::UI::Border::StaticType();
}
    Type *Ailu::UI::Border::GetType()
{
return Ailu::UI::Border::GetPrivateStaticClass();
}
ClassTypeRegister s_register_Border(&Ailu::UI::Border::StaticType, "Ailu::UI::Border");

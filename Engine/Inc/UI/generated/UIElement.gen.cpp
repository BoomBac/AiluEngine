//Generated by ahl
#include "../UIElement.h"
#include <memory>
#include <Objects/Type.h>
#include <Objects/Serialize.h>
#include <Objects/SerializeSpecializations.h>
#include <Framework/Common/Log.h>
using namespace Ailu;
Ailu::Type* Ailu::UI::Z_Construct_UIElement_Type()
{
Ailu::SerializeObject::StaticType();
static std::unique_ptr<Ailu::Type> cur_type = nullptr;
if(cur_type == nullptr)
{
TypeInitializer initializer;
initializer._name = "UIElement";
initializer._size = sizeof(Ailu::UI::UIElement);
initializer._full_name = "Ailu::UI::UIElement";
initializer._is_class = true;
initializer._is_abstract = false;
initializer._namespace = "Ailu::UI";
initializer._base_name = "Ailu::SerializeObject";
initializer._constructor = []()->Ailu::UI::UIElement* {return new Ailu::UI::UIElement;};
Meta meta_visibility;
meta_visibility.Set("Category","");
meta_visibility.Set("IsColor",false);
meta_visibility.Set("IsRange",false);
meta_visibility.Set("IsFloatRange",true);
meta_visibility.Set("RangeMin",0);
meta_visibility.Set("RangeMax",1);
MemberBuilder builder_visibility;
builder_visibility._name = "_visibility";
builder_visibility._type_name = "EVisibility";
builder_visibility._offset = offsetof(UIElement,_visibility);
builder_visibility._is_const = false;
builder_visibility._is_static = false;
builder_visibility._is_public = true;
builder_visibility._is_pointer = false;
builder_visibility._is_ref = false;
builder_visibility._is_template = false;
builder_visibility._meta = meta_visibility;
builder_visibility._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<EVisibility>);
builder_visibility._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<EVisibility>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_visibility));
Meta meta_slot;
meta_slot.Set("Category","");
meta_slot.Set("IsColor",false);
meta_slot.Set("IsRange",false);
meta_slot.Set("IsFloatRange",true);
meta_slot.Set("RangeMin",0);
meta_slot.Set("RangeMax",1);
MemberBuilder builder_slot;
builder_slot._name = "_slot";
builder_slot._type_name = "Slot";
builder_slot._offset = offsetof(UIElement,_slot);
builder_slot._is_const = false;
builder_slot._is_static = false;
builder_slot._is_public = false;
builder_slot._is_pointer = false;
builder_slot._is_ref = false;
builder_slot._is_template = false;
builder_slot._meta = meta_slot;
builder_slot._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<Slot>);
builder_slot._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<Slot>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_slot));
Meta meta_padding;
meta_padding.Set("Category","");
meta_padding.Set("IsColor",false);
meta_padding.Set("IsRange",false);
meta_padding.Set("IsFloatRange",true);
meta_padding.Set("RangeMin",0);
meta_padding.Set("RangeMax",1);
MemberBuilder builder_padding;
builder_padding._name = "_padding";
builder_padding._type_name = "Padding";
builder_padding._offset = offsetof(UIElement,_padding);
builder_padding._is_const = false;
builder_padding._is_static = false;
builder_padding._is_public = false;
builder_padding._is_pointer = false;
builder_padding._is_ref = false;
builder_padding._is_template = false;
builder_padding._meta = meta_padding;
builder_padding._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<Padding>);
builder_padding._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<Padding>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_padding));
Meta meta_transition;
meta_transition.Set("Category","");
meta_transition.Set("IsColor",false);
meta_transition.Set("IsRange",false);
meta_transition.Set("IsFloatRange",true);
meta_transition.Set("RangeMin",0);
meta_transition.Set("RangeMax",1);
MemberBuilder builder_transition;
builder_transition._name = "_transition";
builder_transition._type_name = "Vector2f";
builder_transition._offset = offsetof(UIElement,_transition);
builder_transition._is_const = false;
builder_transition._is_static = false;
builder_transition._is_public = false;
builder_transition._is_pointer = false;
builder_transition._is_ref = false;
builder_transition._is_template = false;
builder_transition._meta = meta_transition;
builder_transition._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<Vector2f>);
builder_transition._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<Vector2f>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_transition));
Meta meta_rotation;
meta_rotation.Set("Category","");
meta_rotation.Set("IsColor",false);
meta_rotation.Set("IsRange",false);
meta_rotation.Set("IsFloatRange",true);
meta_rotation.Set("RangeMin",0);
meta_rotation.Set("RangeMax",1);
MemberBuilder builder_rotation;
builder_rotation._name = "_rotation";
builder_rotation._type_name = "f32";
builder_rotation._offset = offsetof(UIElement,_rotation);
builder_rotation._is_const = false;
builder_rotation._is_static = false;
builder_rotation._is_public = false;
builder_rotation._is_pointer = false;
builder_rotation._is_ref = false;
builder_rotation._is_template = false;
builder_rotation._meta = meta_rotation;
builder_rotation._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<f32>);
builder_rotation._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<f32>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_rotation));
Meta meta_scale;
meta_scale.Set("Category","");
meta_scale.Set("IsColor",false);
meta_scale.Set("IsRange",false);
meta_scale.Set("IsFloatRange",true);
meta_scale.Set("RangeMin",0);
meta_scale.Set("RangeMax",1);
MemberBuilder builder_scale;
builder_scale._name = "_scale";
builder_scale._type_name = "Vector2f";
builder_scale._offset = offsetof(UIElement,_scale);
builder_scale._is_const = false;
builder_scale._is_static = false;
builder_scale._is_public = false;
builder_scale._is_pointer = false;
builder_scale._is_ref = false;
builder_scale._is_template = false;
builder_scale._meta = meta_scale;
builder_scale._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<Vector2f>);
builder_scale._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<Vector2f>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_scale));
cur_type = std::make_unique<Ailu::Type>(initializer);
Ailu::Type::RegisterType(cur_type.get());
}
return cur_type.get();
}

Ailu::Type* Ailu::UI::UIElement::GetPrivateStaticClass()
{
	static Ailu::Type* type = Z_Construct_UIElement_Type();
	return type;
}

template<> Ailu::Type* Ailu::StaticClass<Ailu::UI::UIElement>()
{
return Ailu::UI::UIElement::StaticType();
}
    Type *Ailu::UI::UIElement::GetType()
{
return Ailu::UI::UIElement::GetPrivateStaticClass();
}
ClassTypeRegister s_register_UIElement(&Ailu::UI::UIElement::StaticType, "Ailu::UI::UIElement");
Ailu::Type* Ailu::UI::Z_Construct_Padding_Type()
{
static std::unique_ptr<Ailu::Type> cur_type = nullptr;
if(cur_type == nullptr)
{
TypeInitializer initializer;
initializer._name = "Padding";
initializer._size = sizeof(Ailu::UI::Padding);
initializer._full_name = "Ailu::UI::Padding";
initializer._is_class = true;
initializer._is_abstract = false;
initializer._namespace = "Ailu::UI";
initializer._base_name = "";
initializer._constructor = []()->Ailu::UI::Padding* {return new Ailu::UI::Padding;};
cur_type = std::make_unique<Ailu::Type>(initializer);
Ailu::Type::RegisterType(cur_type.get());
}
return cur_type.get();
}

Ailu::Type* Ailu::UI::Padding::GetPrivateStaticClass()
{
	static Ailu::Type* type = Z_Construct_Padding_Type();
	return type;
}

template<> Ailu::Type* Ailu::StaticClass<Ailu::UI::Padding>()
{
return Ailu::UI::Padding::StaticType();
}
ClassTypeRegister s_register_Padding(&Ailu::UI::Padding::StaticType, "Ailu::UI::Padding");
Ailu::Type* Ailu::UI::Z_Construct_Slot_Type()
{
static std::unique_ptr<Ailu::Type> cur_type = nullptr;
if(cur_type == nullptr)
{
TypeInitializer initializer;
initializer._name = "Slot";
initializer._size = sizeof(Ailu::UI::Slot);
initializer._full_name = "Ailu::UI::Slot";
initializer._is_class = true;
initializer._is_abstract = false;
initializer._namespace = "Ailu::UI";
initializer._base_name = "";
initializer._constructor = []()->Ailu::UI::Slot* {return new Ailu::UI::Slot;};
Meta meta_size;
meta_size.Set("Category","");
meta_size.Set("IsColor",false);
meta_size.Set("IsRange",false);
meta_size.Set("IsFloatRange",true);
meta_size.Set("RangeMin",0);
meta_size.Set("RangeMax",1);
MemberBuilder builder_size;
builder_size._name = "_size";
builder_size._type_name = "Vector2f";
builder_size._offset = offsetof(Slot,_size);
builder_size._is_const = false;
builder_size._is_static = false;
builder_size._is_public = false;
builder_size._is_pointer = false;
builder_size._is_ref = false;
builder_size._is_template = false;
builder_size._meta = meta_size;
builder_size._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<Vector2f>);
builder_size._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<Vector2f>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_size));
Meta meta_anchor;
meta_anchor.Set("Category","");
meta_anchor.Set("IsColor",false);
meta_anchor.Set("IsRange",false);
meta_anchor.Set("IsFloatRange",true);
meta_anchor.Set("RangeMin",0);
meta_anchor.Set("RangeMax",1);
MemberBuilder builder_anchor;
builder_anchor._name = "_anchor";
builder_anchor._type_name = "Vector2f";
builder_anchor._offset = offsetof(Slot,_anchor);
builder_anchor._is_const = false;
builder_anchor._is_static = false;
builder_anchor._is_public = false;
builder_anchor._is_pointer = false;
builder_anchor._is_ref = false;
builder_anchor._is_template = false;
builder_anchor._meta = meta_anchor;
builder_anchor._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<Vector2f>);
builder_anchor._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<Vector2f>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_anchor));
Meta meta_position;
meta_position.Set("Category","");
meta_position.Set("IsColor",false);
meta_position.Set("IsRange",false);
meta_position.Set("IsFloatRange",true);
meta_position.Set("RangeMin",0);
meta_position.Set("RangeMax",1);
MemberBuilder builder_position;
builder_position._name = "_position";
builder_position._type_name = "Vector2f";
builder_position._offset = offsetof(Slot,_position);
builder_position._is_const = false;
builder_position._is_static = false;
builder_position._is_public = false;
builder_position._is_pointer = false;
builder_position._is_ref = false;
builder_position._is_template = false;
builder_position._meta = meta_position;
builder_position._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<Vector2f>);
builder_position._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<Vector2f>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_position));
Meta meta_alignment_h;
meta_alignment_h.Set("Category","");
meta_alignment_h.Set("IsColor",false);
meta_alignment_h.Set("IsRange",false);
meta_alignment_h.Set("IsFloatRange",true);
meta_alignment_h.Set("RangeMin",0);
meta_alignment_h.Set("RangeMax",1);
MemberBuilder builder_alignment_h;
builder_alignment_h._name = "_alignment_h";
builder_alignment_h._type_name = "EAlignment";
builder_alignment_h._offset = offsetof(Slot,_alignment_h);
builder_alignment_h._is_const = false;
builder_alignment_h._is_static = false;
builder_alignment_h._is_public = false;
builder_alignment_h._is_pointer = false;
builder_alignment_h._is_ref = false;
builder_alignment_h._is_template = false;
builder_alignment_h._meta = meta_alignment_h;
builder_alignment_h._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<EAlignment>);
builder_alignment_h._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<EAlignment>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_alignment_h));
Meta meta_alignment_v;
meta_alignment_v.Set("Category","");
meta_alignment_v.Set("IsColor",false);
meta_alignment_v.Set("IsRange",false);
meta_alignment_v.Set("IsFloatRange",true);
meta_alignment_v.Set("RangeMin",0);
meta_alignment_v.Set("RangeMax",1);
MemberBuilder builder_alignment_v;
builder_alignment_v._name = "_alignment_v";
builder_alignment_v._type_name = "EAlignment";
builder_alignment_v._offset = offsetof(Slot,_alignment_v);
builder_alignment_v._is_const = false;
builder_alignment_v._is_static = false;
builder_alignment_v._is_public = false;
builder_alignment_v._is_pointer = false;
builder_alignment_v._is_ref = false;
builder_alignment_v._is_template = false;
builder_alignment_v._meta = meta_alignment_v;
builder_alignment_v._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<EAlignment>);
builder_alignment_v._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<EAlignment>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_alignment_v));
Meta meta_margin;
meta_margin.Set("Category","");
meta_margin.Set("IsColor",false);
meta_margin.Set("IsRange",false);
meta_margin.Set("IsFloatRange",true);
meta_margin.Set("RangeMin",0);
meta_margin.Set("RangeMax",1);
MemberBuilder builder_margin;
builder_margin._name = "_margin";
builder_margin._type_name = "Padding";
builder_margin._offset = offsetof(Slot,_margin);
builder_margin._is_const = false;
builder_margin._is_static = false;
builder_margin._is_public = false;
builder_margin._is_pointer = false;
builder_margin._is_ref = false;
builder_margin._is_template = false;
builder_margin._meta = meta_margin;
builder_margin._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<Padding>);
builder_margin._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<Padding>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_margin));
Meta meta_type;
meta_type.Set("Category","");
meta_type.Set("IsColor",false);
meta_type.Set("IsRange",false);
meta_type.Set("IsFloatRange",true);
meta_type.Set("RangeMin",0);
meta_type.Set("RangeMax",1);
MemberBuilder builder_type;
builder_type._name = "_type";
builder_type._type_name = "ESlotType";
builder_type._offset = offsetof(Slot,_type);
builder_type._is_const = false;
builder_type._is_static = false;
builder_type._is_public = false;
builder_type._is_pointer = false;
builder_type._is_ref = false;
builder_type._is_template = false;
builder_type._meta = meta_type;
builder_type._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<ESlotType>);
builder_type._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<ESlotType>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_type));
Meta meta_size_policy_h;
meta_size_policy_h.Set("Category","");
meta_size_policy_h.Set("IsColor",false);
meta_size_policy_h.Set("IsRange",false);
meta_size_policy_h.Set("IsFloatRange",true);
meta_size_policy_h.Set("RangeMin",0);
meta_size_policy_h.Set("RangeMax",1);
MemberBuilder builder_size_policy_h;
builder_size_policy_h._name = "_size_policy_h";
builder_size_policy_h._type_name = "ESizePolicy";
builder_size_policy_h._offset = offsetof(Slot,_size_policy_h);
builder_size_policy_h._is_const = false;
builder_size_policy_h._is_static = false;
builder_size_policy_h._is_public = false;
builder_size_policy_h._is_pointer = false;
builder_size_policy_h._is_ref = false;
builder_size_policy_h._is_template = false;
builder_size_policy_h._meta = meta_size_policy_h;
builder_size_policy_h._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<ESizePolicy>);
builder_size_policy_h._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<ESizePolicy>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_size_policy_h));
Meta meta_size_policy_v;
meta_size_policy_v.Set("Category","");
meta_size_policy_v.Set("IsColor",false);
meta_size_policy_v.Set("IsRange",false);
meta_size_policy_v.Set("IsFloatRange",true);
meta_size_policy_v.Set("RangeMin",0);
meta_size_policy_v.Set("RangeMax",1);
MemberBuilder builder_size_policy_v;
builder_size_policy_v._name = "_size_policy_v";
builder_size_policy_v._type_name = "ESizePolicy";
builder_size_policy_v._offset = offsetof(Slot,_size_policy_v);
builder_size_policy_v._is_const = false;
builder_size_policy_v._is_static = false;
builder_size_policy_v._is_public = false;
builder_size_policy_v._is_pointer = false;
builder_size_policy_v._is_ref = false;
builder_size_policy_v._is_template = false;
builder_size_policy_v._meta = meta_size_policy_v;
builder_size_policy_v._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<ESizePolicy>);
builder_size_policy_v._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<ESizePolicy>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_size_policy_v));
Meta meta_is_size_to_content;
meta_is_size_to_content.Set("Category","");
meta_is_size_to_content.Set("IsColor",false);
meta_is_size_to_content.Set("IsRange",false);
meta_is_size_to_content.Set("IsFloatRange",true);
meta_is_size_to_content.Set("RangeMin",0);
meta_is_size_to_content.Set("RangeMax",1);
MemberBuilder builder_is_size_to_content;
builder_is_size_to_content._name = "_is_size_to_content";
builder_is_size_to_content._type_name = "bool";
builder_is_size_to_content._offset = offsetof(Slot,_is_size_to_content);
builder_is_size_to_content._is_const = false;
builder_is_size_to_content._is_static = false;
builder_is_size_to_content._is_public = false;
builder_is_size_to_content._is_pointer = false;
builder_is_size_to_content._is_ref = false;
builder_is_size_to_content._is_template = false;
builder_is_size_to_content._meta = meta_is_size_to_content;
builder_is_size_to_content._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<bool>);
builder_is_size_to_content._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<bool>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_is_size_to_content));
Meta meta_fill_rate;
meta_fill_rate.Set("Category","");
meta_fill_rate.Set("IsColor",false);
meta_fill_rate.Set("IsRange",false);
meta_fill_rate.Set("IsFloatRange",true);
meta_fill_rate.Set("RangeMin",0);
meta_fill_rate.Set("RangeMax",1);
MemberBuilder builder_fill_rate;
builder_fill_rate._name = "_fill_rate";
builder_fill_rate._type_name = "f32";
builder_fill_rate._offset = offsetof(Slot,_fill_rate);
builder_fill_rate._is_const = false;
builder_fill_rate._is_static = false;
builder_fill_rate._is_public = false;
builder_fill_rate._is_pointer = false;
builder_fill_rate._is_ref = false;
builder_fill_rate._is_template = false;
builder_fill_rate._meta = meta_fill_rate;
builder_fill_rate._serialize_fn = static_cast<SerializeFunc>(&SerializePrimitive<f32>);
builder_fill_rate._deserialize_fn = static_cast<DeserializeFunc>(&DeserializePrimitive<f32>);
initializer._properties.emplace_back(MemberBuilder::BuildProperty(builder_fill_rate));
cur_type = std::make_unique<Ailu::Type>(initializer);
Ailu::Type::RegisterType(cur_type.get());
}
return cur_type.get();
}

Ailu::Type* Ailu::UI::Slot::GetPrivateStaticClass()
{
	static Ailu::Type* type = Z_Construct_Slot_Type();
	return type;
}

template<> Ailu::Type* Ailu::StaticClass<Ailu::UI::Slot>()
{
return Ailu::UI::Slot::StaticType();
}
ClassTypeRegister s_register_Slot(&Ailu::UI::Slot::StaticType, "Ailu::UI::Slot");
static std::unique_ptr<Ailu::Enum> s_enum_type_EAlignment = nullptr;
//Enum EAlignment begin...........................
const Ailu::Enum* Z_Construct_Enum_EAlignment_Type()
{
if(s_enum_type_EAlignment == nullptr)
{
EnumInitializer initializer;
initializer._name = "EAlignment";
initializer._str_to_enum_lut["kLeft"] = 0;
initializer._str_to_enum_lut["kCenter"] = 1;
initializer._str_to_enum_lut["kRight"] = 2;
initializer._str_to_enum_lut["kTop"] = 3;
initializer._str_to_enum_lut["kBottom"] = 4;
initializer._str_to_enum_lut["kFill"] = 5;
s_enum_type_EAlignment = std::make_unique<Ailu::Enum>(initializer);
Ailu::Enum::RegisterEnum(s_enum_type_EAlignment.get());
}
return s_enum_type_EAlignment.get();
}
static Ailu::EnumTypeRegister g_register_EAlignment(Z_Construct_Enum_EAlignment_Type);
template<> const Ailu::Enum* Ailu::StaticEnum<Ailu::UI::EAlignment>()
{
return s_enum_type_EAlignment.get();
}
//Enum EAlignment end...........................

static std::unique_ptr<Ailu::Enum> s_enum_type_ESlotType = nullptr;
//Enum ESlotType begin...........................
const Ailu::Enum* Z_Construct_Enum_ESlotType_Type()
{
if(s_enum_type_ESlotType == nullptr)
{
EnumInitializer initializer;
initializer._name = "ESlotType";
initializer._str_to_enum_lut["kCanvas"] = 0;
initializer._str_to_enum_lut["kVerticalBox"] = 1;
initializer._str_to_enum_lut["kHorizontalBox"] = 2;
s_enum_type_ESlotType = std::make_unique<Ailu::Enum>(initializer);
Ailu::Enum::RegisterEnum(s_enum_type_ESlotType.get());
}
return s_enum_type_ESlotType.get();
}
static Ailu::EnumTypeRegister g_register_ESlotType(Z_Construct_Enum_ESlotType_Type);
template<> const Ailu::Enum* Ailu::StaticEnum<Ailu::UI::ESlotType>()
{
return s_enum_type_ESlotType.get();
}
//Enum ESlotType end...........................

static std::unique_ptr<Ailu::Enum> s_enum_type_ESizePolicy = nullptr;
//Enum ESizePolicy begin...........................
const Ailu::Enum* Z_Construct_Enum_ESizePolicy_Type()
{
if(s_enum_type_ESizePolicy == nullptr)
{
EnumInitializer initializer;
initializer._name = "ESizePolicy";
initializer._str_to_enum_lut["kFixed"] = 0;
initializer._str_to_enum_lut["kFill"] = 1;
initializer._str_to_enum_lut["kAuto"] = 2;
s_enum_type_ESizePolicy = std::make_unique<Ailu::Enum>(initializer);
Ailu::Enum::RegisterEnum(s_enum_type_ESizePolicy.get());
}
return s_enum_type_ESizePolicy.get();
}
static Ailu::EnumTypeRegister g_register_ESizePolicy(Z_Construct_Enum_ESizePolicy_Type);
template<> const Ailu::Enum* Ailu::StaticEnum<Ailu::UI::ESizePolicy>()
{
return s_enum_type_ESizePolicy.get();
}
//Enum ESizePolicy end...........................

static std::unique_ptr<Ailu::Enum> s_enum_type_EVisibility = nullptr;
//Enum EVisibility begin...........................
const Ailu::Enum* Z_Construct_Enum_EVisibility_Type()
{
if(s_enum_type_EVisibility == nullptr)
{
EnumInitializer initializer;
initializer._name = "EVisibility";
initializer._str_to_enum_lut["kVisible"] = 0;
initializer._str_to_enum_lut["kHide"] = 1;
s_enum_type_EVisibility = std::make_unique<Ailu::Enum>(initializer);
Ailu::Enum::RegisterEnum(s_enum_type_EVisibility.get());
}
return s_enum_type_EVisibility.get();
}
static Ailu::EnumTypeRegister g_register_EVisibility(Z_Construct_Enum_EVisibility_Type);
template<> const Ailu::Enum* Ailu::StaticEnum<Ailu::UI::EVisibility>()
{
return s_enum_type_EVisibility.get();
}
//Enum EVisibility end...........................


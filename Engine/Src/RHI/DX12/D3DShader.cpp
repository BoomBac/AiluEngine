#include "pch.h"
#include <d3dcompiler.h>
#include <dxcapi.h>
#include <atlcomcli.h>

#include "GlobalMarco.h"
#include "RHI/DX12/D3DShader.h"
#include "RHI/DX12/dxhelper.h"
#include "Framework/Common/Utils.h"
#include "RHI/DX12/D3DContext.h"
#include "Framework/Common/Utils.h"
#include "RHI/DX12/D3DConstants.h"


namespace Ailu
{
	static uint32_t GetPerFramePropertyOffset(std::string_view name)
	{
		if (name == "_MatrixV")
			return 0;
		else if (name == "_MatrixVP")
			return 64;
		else if (name == "_Color")
			return D3DConstants::kPerFrameDataSize;
		return 0;
	}
	//shader model 6.0 and higher,can't see cbuffer info in PIX!!!!
	static bool CreateFromFileDXC(const std::wstring& filename, const std::wstring& entryPoint, const std::wstring& pTarget, ComPtr<ID3DBlob>& p_blob,
		ComPtr<ID3D12ShaderReflection>& shader_reflection)
	{
		CComPtr<IDxcUtils> pUtils;
		CComPtr<IDxcCompiler3> pCompiler;
		DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(&pUtils));
		DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&pCompiler));

		CComPtr<IDxcIncludeHandler> pIncludeHandler;
		pUtils->CreateDefaultIncludeHandler(&pIncludeHandler);

		LOG_INFO(filename.c_str());
		LOG_INFO(entryPoint.c_str());
		LOG_INFO(pTarget.c_str());

		LPCWSTR pszArgs[] =
		{
			filename.c_str(),            // Optional shader source file name for error reporting and for PIX shader source view.  
			L"-E", entryPoint.c_str(),              // Entry point.
			L"-T", pTarget.c_str(),            // Target.
			L"-Zi",                      // Enable debug information.
			L"-D", L"MYDEFINE=1",        // A single define.
			L"-Fo", L"myshader.bin",     // Optional. Stored in the pdb. 
			L"-Fd", L"myshader.pdb",     // The file name of the pdb. This must either be supplied or the autogenerated file name must be used.
			L"-Qstrip_reflect",          // Strip reflection into a separate blob. 
		};


		CComPtr<IDxcBlobEncoding> pSource = nullptr;
		pUtils->LoadFile(filename.c_str(), nullptr, &pSource);
		DxcBuffer Source;
		Source.Ptr = pSource->GetBufferPointer();
		Source.Size = pSource->GetBufferSize();
		Source.Encoding = DXC_CP_ACP; // Assume BOM says UTF8 or UTF16 or this is ANSI text.

		//
		// Compile it with specified arguments.
		//
		CComPtr<IDxcResult> pResults;
		pCompiler->Compile(
			&Source,                // Source buffer.
			pszArgs,                // Array of pointers to arguments.
			_countof(pszArgs),      // Number of arguments.
			pIncludeHandler,        // User-provided interface to handle #include directives (optional).
			IID_PPV_ARGS(&pResults) // Compiler output status, buffer, and errors.
		);

		//
		// Print errors if present.
		//
		CComPtr<IDxcBlobUtf8> pErrors = nullptr;
		pResults->GetOutput(DXC_OUT_ERRORS, IID_PPV_ARGS(&pErrors), nullptr);
		// Note that d3dcompiler would return null if no errors or warnings are present.  
		// IDxcCompiler3::Compile will always return an error buffer, but its length will be zero if there are no warnings or errors.
		if (pErrors != nullptr && pErrors->GetStringLength() != 0)
			LOG_ERROR("{}", pErrors->GetStringPointer());

		//
		// Quit if the compilation failed.
		//
		HRESULT hrStatus;
		pResults->GetStatus(&hrStatus);
		if (FAILED(hrStatus))
		{
			LOG_ERROR("Compilation Failed");
			return false;
		}

		//
		// Save shader binary.
		//
		CComPtr<IDxcBlob> pShader = nullptr;
		CComPtr<IDxcBlobUtf16> pShaderName = nullptr;
		pResults->GetOutput(DXC_OUT_OBJECT, IID_PPV_ARGS(&p_blob), &pShaderName);

		CComPtr<IDxcBlob> pReflectionData;
		pResults->GetOutput(DXC_OUT_REFLECTION, IID_PPV_ARGS(&pReflectionData), nullptr);
		if (pReflectionData != nullptr)
		{
			// Optionally, save reflection blob for later here.

			// Create reflection interface.
			DxcBuffer ReflectionData;
			ReflectionData.Encoding = DXC_CP_ACP;
			ReflectionData.Ptr = pReflectionData->GetBufferPointer();
			ReflectionData.Size = pReflectionData->GetBufferSize();
			pUtils->CreateReflection(&ReflectionData, IID_PPV_ARGS(shader_reflection.GetAddressOf()));
		}
		return true;
	}

	static void CreateFromFileFXC(const std::wstring& filename, const std::string& entryPoint, const std::string& pTarget, ComPtr<ID3DBlob>& p_blob, 
		ComPtr<ID3D12ShaderReflection>& shader_reflection)
	{
		ID3DBlob* pErrorBlob = nullptr;
		D3DCompileFromFile(filename.c_str(), nullptr, D3D_COMPILE_STANDARD_FILE_INCLUDE, entryPoint.c_str(), pTarget.c_str(), 0, 0, &p_blob, &pErrorBlob);
		if (pErrorBlob)
		{
			OutputDebugStringA(reinterpret_cast<const char*>(pErrorBlob->GetBufferPointer()));
			pErrorBlob->Release();
		}
		ID3D12ShaderReflection* pReflection = NULL;
		D3DReflect(p_blob->GetBufferPointer(), p_blob->GetBufferSize(), IID_ID3D12ShaderReflection, (void**)&shader_reflection);
	}

	static DXGI_FORMAT GetFormatBySemanticName(const char* semantic)
	{
		if (!std::strcmp(semantic, D3DConstants::kSemanticPosition)) return DXGI_FORMAT_R32G32B32_FLOAT;
		else if (!std::strcmp(semantic, D3DConstants::kSemanticNormal)) return DXGI_FORMAT_R32G32B32_FLOAT;
		else if (!std::strcmp(semantic, D3DConstants::kSemanticTangent)) return DXGI_FORMAT_R32G32B32A32_FLOAT;
		else if (!std::strcmp(semantic, D3DConstants::kSemanticColor)) return DXGI_FORMAT_R32G32B32A32_FLOAT;
		else if (!std::strcmp(semantic, D3DConstants::kSemanticTexcoord)) return DXGI_FORMAT_R32G32_FLOAT;
	}

	void D3DShader::GenerateRootSignature()
	{
		D3D12_FEATURE_DATA_ROOT_SIGNATURE featureData = {};
		featureData.HighestVersion = D3D_ROOT_SIGNATURE_VERSION_1_1;
		auto device = D3DContext::GetInstance()->GetDevice();
		if (FAILED(device->CheckFeatureSupport(D3D12_FEATURE_ROOT_SIGNATURE, &featureData, sizeof(featureData))))
		{
			featureData.HighestVersion = D3D_ROOT_SIGNATURE_VERSION_1_0;
		}
		CD3DX12_DESCRIPTOR_RANGE1 ranges[32]{};
		CD3DX12_ROOT_PARAMETER1 rootParameters[32]{};
		int cbuf_mask = 0,texture_count = 0;
		for (auto it = _bind_res_infos.begin(); it != _bind_res_infos.end(); it++)
		{
			auto& desc = it->second;
			if (desc._res_type == EBindResDescType::kCBufferAttribute) continue;
			if (desc._res_type == EBindResDescType::kConstBuffer)
			{
				if (desc._name == D3DConstants::kCBufNameSceneObject) cbuf_mask |= 0x01;
				else if (desc._name == D3DConstants::kCBufNameSceneMaterial) cbuf_mask |= 0x02;
				else if (desc._name == D3DConstants::kCBufNameSceneState) cbuf_mask |= 0x04;
			}
		}
		uint8_t root_param_index = 0;
		if (cbuf_mask & 0x01)
		{
			_bind_res_infos[D3DConstants::kCBufNameSceneObject]._bind_slot = root_param_index;
			rootParameters[root_param_index++].InitAsConstantBufferView(0u);
		}
		if (cbuf_mask & 0x02)
		{
			_bind_res_infos[D3DConstants::kCBufNameSceneMaterial]._bind_slot = root_param_index;
			rootParameters[root_param_index++].InitAsConstantBufferView(1u);
		}
		if (cbuf_mask & 0x04)
		{
			_bind_res_infos[D3DConstants::kCBufNameSceneState]._bind_slot = root_param_index;
			rootParameters[root_param_index++].InitAsConstantBufferView(2u);
		}
		for (auto it = _bind_res_infos.begin(); it != _bind_res_infos.end(); it++)
		{
			auto& desc = it->second;
			if (desc._res_type == EBindResDescType::kTexture2D)
			{
				++texture_count;
				ranges[root_param_index].Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, desc._res_slot, 0, D3D12_DESCRIPTOR_RANGE_FLAG_DATA_STATIC);
				rootParameters[root_param_index].InitAsDescriptorTable(1, &ranges[root_param_index]);
				desc._bind_slot = root_param_index;
				++root_param_index;
			}
		}
		D3D12_STATIC_SAMPLER_DESC* p_sampler = nullptr;
		uint8_t sampler_num = 0;
		if (texture_count > 0)
		{
			D3D12_STATIC_SAMPLER_DESC sampler = {};
			sampler.Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;
			sampler.AddressU = D3D12_TEXTURE_ADDRESS_MODE_BORDER;
			sampler.AddressV = D3D12_TEXTURE_ADDRESS_MODE_BORDER;
			sampler.AddressW = D3D12_TEXTURE_ADDRESS_MODE_BORDER;
			sampler.MipLODBias = 0;
			sampler.MaxAnisotropy = 0;
			sampler.ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
			sampler.BorderColor = D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK;
			sampler.MinLOD = 0.0f;
			sampler.MaxLOD = D3D12_FLOAT32_MAX;
			sampler.ShaderRegister = 0;
			sampler.RegisterSpace = 0;
			sampler.ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
			p_sampler = &sampler;
			++sampler_num;
		}
		D3D12_ROOT_SIGNATURE_FLAGS rootSignatureFlags =
			D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |
			D3D12_ROOT_SIGNATURE_FLAG_DENY_HULL_SHADER_ROOT_ACCESS |
			D3D12_ROOT_SIGNATURE_FLAG_DENY_DOMAIN_SHADER_ROOT_ACCESS |
			D3D12_ROOT_SIGNATURE_FLAG_DENY_GEOMETRY_SHADER_ROOT_ACCESS;
		CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC rootSignatureDesc;
		rootSignatureDesc.Init_1_1(root_param_index, rootParameters, sampler_num, p_sampler, rootSignatureFlags);
		//rootSignatureDesc.Init_1_1(root_param_count, rootParameters, 0u, nullptr, rootSignatureFlags);
		ComPtr<ID3DBlob> signature;
		ComPtr<ID3DBlob> error;
		ThrowIfFailed(D3DX12SerializeVersionedRootSignature(&rootSignatureDesc, featureData.HighestVersion, &signature, &error));
		ThrowIfFailed(device->CreateRootSignature(0, signature->GetBufferPointer(), signature->GetBufferSize(), IID_PPV_ARGS(&_p_sig)));
	}

	void D3DShader::LoadShaderRelfection(ID3D12ShaderReflection* reflection, const EShaderType& type)
	{
		D3D12_SHADER_DESC desc{};
		reflection->GetDesc(&desc);
		switch (type)
		{
			case Ailu::EShaderType::kVertex:
			{
				if (desc.InputParameters > 10)
				{
					AL_ASSERT(true, "LayoutDesc count must less than 10");
					return;
				}
				for (uint32_t i = 0u; i < desc.InputParameters; i++)
				{
					D3D12_SIGNATURE_PARAMETER_DESC input_desc{};
					reflection->GetInputParameterDesc(i, &input_desc);
					_vertex_input_layout[i] = D3D12_INPUT_ELEMENT_DESC{ input_desc.SemanticName, 0, GetFormatBySemanticName(input_desc.SemanticName), i, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 };
					++_vertex_input_num;
				}
				for (uint32_t i = 0u; i < desc.BoundResources; i++)
				{
					D3D12_SHADER_INPUT_BIND_DESC bind_desc{};
					reflection->GetResourceBindingDesc(i, &bind_desc);
					auto res_type = bind_desc.Type;
					if (res_type == D3D_SHADER_INPUT_TYPE::D3D_SIT_CBUFFER)
					{
						_bind_res_infos.insert(std::make_pair(bind_desc.Name, ShaderBindResourceInfo{EBindResDescType::kConstBuffer,static_cast<uint16_t>(bind_desc.BindPoint),0u,bind_desc.Name}));
					}
					else if (res_type == D3D_SHADER_INPUT_TYPE::D3D_SIT_TEXTURE)
					{
						_bind_res_infos.insert(std::make_pair(bind_desc.Name, ShaderBindResourceInfo{ EBindResDescType::kTexture2D,static_cast<uint16_t>(bind_desc.BindPoint),0u,bind_desc.Name }));
					}
					else if (res_type == D3D_SHADER_INPUT_TYPE::D3D_SIT_SAMPLER)
					{
						_bind_res_infos.insert(std::make_pair(bind_desc.Name, ShaderBindResourceInfo{ EBindResDescType::kSampler,static_cast<uint16_t>(bind_desc.BindPoint),0u,bind_desc.Name }));
					}
				}
			}
			case Ailu::EShaderType::kPixel:
			{			
				for (uint32_t i = 0u; i < desc.BoundResources; i++)
				{
					D3D12_SHADER_INPUT_BIND_DESC bind_desc{};
					reflection->GetResourceBindingDesc(i, &bind_desc);
					auto res_type = bind_desc.Type;
					if (res_type == D3D_SHADER_INPUT_TYPE::D3D_SIT_CBUFFER)
					{
						_bind_res_infos.insert(std::make_pair(bind_desc.Name, ShaderBindResourceInfo{ EBindResDescType::kConstBuffer,static_cast<uint16_t>(bind_desc.BindPoint),0u,bind_desc.Name }));
					}
					else if (res_type == D3D_SHADER_INPUT_TYPE::D3D_SIT_TEXTURE)
					{
						_bind_res_infos.insert(std::make_pair(bind_desc.Name, ShaderBindResourceInfo{ EBindResDescType::kTexture2D,static_cast<uint16_t>(bind_desc.BindPoint),0u,bind_desc.Name }));
					}
					else if (res_type == D3D_SHADER_INPUT_TYPE::D3D_SIT_SAMPLER)
					{
						_bind_res_infos.insert(std::make_pair(bind_desc.Name, ShaderBindResourceInfo{ EBindResDescType::kSampler,static_cast<uint16_t>(bind_desc.BindPoint),0u,bind_desc.Name }));
					}
				}
				for (uint32_t i = 0u; i < desc.ConstantBuffers; i++)
				{
					auto cbuf = reflection->GetConstantBufferByIndex(i);
					D3D12_SHADER_BUFFER_DESC desc{};
					cbuf->GetDesc(&desc);
					for (uint32_t j = 0u; j < desc.Variables; j++)
					{
						auto variable = cbuf->GetVariableByIndex(j);
						D3D12_SHADER_VARIABLE_DESC vdesc{};
						variable->GetDesc(&vdesc);
						uint8_t offset = (uint8_t)vdesc.StartOffset;
						uint8_t size = (uint8_t)vdesc.Size;
						uint16_t variable_info = 0u;
						variable_info |= offset;
						variable_info <<= 8;
						variable_info |= size;
						auto info = ShaderBindResourceInfo{ EBindResDescType::kCBufferAttribute,variable_info,0u,vdesc.Name };
						_bind_res_infos.insert(std::make_pair(vdesc.Name, info));
					}
				}
			}
		}
	}

	uint16_t D3DShader::GetVariableOffset(const std::string& name) const
	{
		auto it = _variable_offset.find(name);
		if (it == _variable_offset.end())
		{
			//LOG_WARNING("variable: {} don't exist in shader: {}", name, _name);
			return 0;
		}
		return it->second;
	}

	D3DShader::D3DShader(const std::string_view file_name, const std::string_view shader_name, const uint32_t& id, EShaderType type)
	{

	}

	D3DShader::D3DShader(const std::string_view file_name, const std::string_view shader_name, const uint32_t& id) : _name(shader_name) , _id(id)
	{
		if (!_b_init_buffer)
		{
			m_cbvHeap = D3DContext::GetInstance()->GetDescriptorHeap();
			_b_init_buffer = true;
		}
		_desc_size = D3DContext::GetInstance()->GetDevice()->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
		_p_cbuffer = D3DContext::GetInstance()->GetCBufferPtr();
#if defined(_DEBUG)
		// Enable better shader debugging with the graphics debugging tools.
		UINT compileFlags = D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION;
#else
		UINT compileFlags = 0;
#endif

#ifdef SHADER_DXC
		CreateFromFileDXC(ToWChar(file_name.data()), L"VSMain", D3DConstants::kVSModel_6_1, _p_vblob, _p_reflection);
		LoadShaderRelfection(_p_reflection.Get());
		CreateFromFileDXC(ToWChar(file_name.data()), L"PSMain", D3DConstants::kPSModel_6_1, _p_pblob, _p_reflection);
		LoadShaderRelfection(_p_reflection.Get());
#else
		CreateFromFileFXC(ToWChar(file_name.data()), "VSMain", "vs_5_0", _p_vblob, _p_v_reflection);
		LoadShaderRelfection(_p_v_reflection.Get(),EShaderType::kVertex);
		CreateFromFileFXC(ToWChar(file_name.data()), "PSMain", "ps_5_0", _p_pblob, _p_p_reflection);
		LoadShaderRelfection(_p_p_reflection.Get(),EShaderType::kPixel);
#endif // SHADER_DXC
		GenerateRootSignature();
		auto it = _bind_res_infos.find(D3DConstants::kCBufNameSceneMaterial);
		if (it != _bind_res_infos.end()) _per_mat_buf_bind_slot = it->second._bind_slot;
	}

	D3DShader::~D3DShader()
	{
	}

	std::pair<D3D12_INPUT_ELEMENT_DESC*, uint8_t> D3DShader::GetVertexInputLayout()
	{
		return std::make_pair(_vertex_input_layout, _vertex_input_num);
	}

	uint8_t* D3DShader::GetCBufferPtr(uint32_t index)
	{
		if (index > D3DConstants::kMaxMaterialDataCount)
		{
			AL_ASSERT(true, "Material num more than MaxMaterialDataCount!");
			return nullptr;
		}
		return _p_cbuffer + D3DConstants::kPerFrameDataSize + index * D3DConstants::kPerMaterialDataSize;
	}

	void D3DShader::Bind()
	{
		auto cmdlist = D3DContext::GetInstance()->GetCmdList();
		cmdlist->SetGraphicsRootSignature(_p_sig.Get());
		if (_per_mat_buf_bind_slot == -1) return;
		D3D12_GPU_DESCRIPTOR_HANDLE matHandle;
		matHandle.ptr = m_cbvHeap->GetGPUDescriptorHandleForHeapStart().ptr + _desc_size;	
		cmdlist->SetGraphicsRootDescriptorTable(_per_mat_buf_bind_slot, matHandle);
	}

	inline std::string D3DShader::GetName() const
	{
		return _name;
	}

	inline uint32_t D3DShader::GetID() const
	{
		return _id;
	}

	inline const std::unordered_map<std::string, ShaderBindResourceInfo>& D3DShader::GetBindResInfo() const
	{
		return _bind_res_infos;
	}

	void D3DShader::Bind(uint32_t index)
	{
		if (_per_mat_buf_bind_slot == -1) return;
		if (index > D3DConstants::kMaxMaterialDataCount)
		{
			AL_ASSERT(true, "Material num more than MaxMaterialDataCount!");
			return;
		}
		auto context = D3DContext::GetInstance();
		context->GetCmdList()->SetGraphicsRootConstantBufferView(_per_mat_buf_bind_slot, context->GetCBufferViewDesc(1 + index).BufferLocation);
	}

	void D3DShader::SetGlobalVector(const std::string& name, const Vector4f& vector)
	{
		auto it = _variable_offset.find(name);
		if (it == _variable_offset.end())
		{
			//LOG_WARNING("variable: {} don't exist in shader: {}",name,_name);
			return;
		}
		memcpy(_p_cbuffer + GetPerFramePropertyOffset(name), &vector, sizeof(vector));
	}

	void D3DShader::SetGlobalVector(const std::string& name, const Vector3f& vector)
	{
	}

	void D3DShader::SetGlobalVector(const std::string& name, const Vector2f& vector)
	{
	}

	void D3DShader::SetGlobalMatrix(const std::string& name, const Matrix4x4f& mat)
	{
		memcpy(_p_cbuffer + GetPerFramePropertyOffset(name), &mat, sizeof(mat));
	}

	void D3DShader::SetGlobalMatrix(const std::string& name, const Matrix3x3f& mat)
	{
	}

	void* D3DShader::GetByteCode(EShaderType type)
	{
		switch (type)
		{
		case Ailu::EShaderType::kVertex:
			return reinterpret_cast<void*>(_p_vblob.Get());
		case Ailu::EShaderType::kPixel:
			return reinterpret_cast<void*>(_p_pblob.Get());
		}
		return nullptr;
	}

	ComPtr<ID3D12RootSignature> D3DShader::GetSignature() const
	{
		return _p_sig;
	}
	ID3D12ShaderReflection* D3DShader::GetD3DReflectionInfo() const
	{
		return _p_p_reflection.Get();
	}
	ID3D12ShaderReflection* D3DShader::GetD3DReflectionInfo(const EShaderType& type) const
	{
		switch (type)
		{
		case Ailu::EShaderType::kVertex:
			return _p_v_reflection.Get();
		case Ailu::EShaderType::kPixel:
			return _p_p_reflection.Get();
		}
	}
}

#include "pch.h"
#include <atlcomcli.h>
#include <d3dcompiler.h>
#include <dxcapi.h>

#include "Framework/Common/LogMgr.h"
#include "Framework/Common/Utils.h"
#include "GlobalMarco.h"
#include "RHI/DX12/D3DContext.h"
#include "RHI/DX12/D3DShader.h"
#include "RHI/DX12/dxhelper.h"



namespace Ailu
{
	static uint32_t GetPerFramePropertyOffset(std::string_view name)
	{
		if (name == "_MatrixV")
			return 0;
		else if (name == "_MatrixVP")
			return 64;
		else if (name == "_Color")
			return RenderConstants::kPerFrameDataSize;
		return 0;
	}
	//shader model 6.0 and higher,can't see cbuffer info in PIX!!!!
	static bool CreateFromFileDXC(const std::wstring& filename, const std::wstring& entryPoint, const std::wstring& pTarget, ComPtr<ID3DBlob>& p_blob,
		ComPtr<ID3D12ShaderReflection>& shader_reflection)
	{
		CComPtr<IDxcUtils> pUtils;
		CComPtr<IDxcCompiler3> pCompiler;
		DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(&pUtils));
		DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&pCompiler));

		CComPtr<IDxcIncludeHandler> pIncludeHandler;
		pUtils->CreateDefaultIncludeHandler(&pIncludeHandler);

		LOG_INFO(filename.c_str());
		LOG_INFO(entryPoint.c_str());
		LOG_INFO(pTarget.c_str());

		LPCWSTR pszArgs[] =
		{
			filename.c_str(),            // Optional shader source file name for error reporting and for PIX shader source view.  
			L"-E", entryPoint.c_str(),              // Entry point.
			L"-T", pTarget.c_str(),            // Target.
			L"-Zi",                      // Enable debug information.
			L"-D", L"MYDEFINE=1",        // A single define.
			L"-Fo", L"myshader.bin",     // Optional. Stored in the pdb. 
			L"-Fd", L"myshader.pdb",     // The file name of the pdb. This must either be supplied or the autogenerated file name must be used.
			L"-Qstrip_reflect",          // Strip reflection into a separate blob. 
		};


		CComPtr<IDxcBlobEncoding> pSource = nullptr;
		pUtils->LoadFile(filename.c_str(), nullptr, &pSource);
		DxcBuffer Source;
		Source.Ptr = pSource->GetBufferPointer();
		Source.Size = pSource->GetBufferSize();
		Source.Encoding = DXC_CP_ACP; // Assume BOM says UTF8 or UTF16 or this is ANSI text.

		//
		// Compile it with specified arguments.
		//
		CComPtr<IDxcResult> pResults;
		pCompiler->Compile(
			&Source,                // Source buffer.
			pszArgs,                // Array of pointers to arguments.
			_countof(pszArgs),      // Number of arguments.
			pIncludeHandler,        // User-provided interface to handle #include directives (optional).
			IID_PPV_ARGS(&pResults) // Compiler output status, buffer, and errors.
		);

		//
		// Print errors if present.
		//
		CComPtr<IDxcBlobUtf8> pErrors = nullptr;
		pResults->GetOutput(DXC_OUT_ERRORS, IID_PPV_ARGS(&pErrors), nullptr);
		// Note that d3dcompiler would return null if no errors or warnings are present.  
		// IDxcCompiler3::Compile will always return an error buffer, but its length will be zero if there are no warnings or errors.
		if (pErrors != nullptr && pErrors->GetStringLength() != 0)
			LOG_ERROR("{}", pErrors->GetStringPointer());

		//
		// Quit if the compilation failed.
		//
		HRESULT hrStatus;
		pResults->GetStatus(&hrStatus);
		if (FAILED(hrStatus))
		{
			LOG_ERROR("Compilation Failed");
			return false;
		}

		//
		// Save shader binary.
		//
		CComPtr<IDxcBlob> pShader = nullptr;
		CComPtr<IDxcBlobUtf16> pShaderName = nullptr;
		pResults->GetOutput(DXC_OUT_OBJECT, IID_PPV_ARGS(&p_blob), &pShaderName);

		CComPtr<IDxcBlob> pReflectionData;
		pResults->GetOutput(DXC_OUT_REFLECTION, IID_PPV_ARGS(&pReflectionData), nullptr);
		if (pReflectionData != nullptr)
		{
			// Optionally, save reflection blob for later here.

			// Create reflection interface.
			DxcBuffer ReflectionData;
			ReflectionData.Encoding = DXC_CP_ACP;
			ReflectionData.Ptr = pReflectionData->GetBufferPointer();
			ReflectionData.Size = pReflectionData->GetBufferSize();
			pUtils->CreateReflection(&ReflectionData, IID_PPV_ARGS(shader_reflection.GetAddressOf()));
		}
		return true;
	}

	static bool CreateFromFileFXC(const std::wstring& filename, const std::string& entryPoint, const std::string& pTarget, ComPtr<ID3DBlob>& p_blob,
		ComPtr<ID3D12ShaderReflection>& shader_reflection)
	{
		ID3DBlob* pErrorBlob = nullptr;
		D3D_SHADER_MACRO macros[] = { {"TEST","0"},{NULL,NULL} };
		D3DCompileFromFile(filename.c_str(), macros, D3D_COMPILE_STANDARD_FILE_INCLUDE, entryPoint.c_str(), pTarget.c_str(), D3DCOMPILE_DEBUG, 0, &p_blob, &pErrorBlob);
		if (pErrorBlob)
		{
			OutputDebugStringA(reinterpret_cast<const char*>(pErrorBlob->GetBufferPointer()));
			pErrorBlob->Release();
		}
		if (p_blob != nullptr)
		{
			ID3D12ShaderReflection* pReflection = NULL;
			D3DReflect(p_blob->GetBufferPointer(), p_blob->GetBufferSize(), IID_ID3D12ShaderReflection, (void**)&shader_reflection);
			return true;
		}
		return false;
	}

	static D3D12_PRIMITIVE_TOPOLOGY ConvertTopologyToType(D3D12_PRIMITIVE_TOPOLOGY_TYPE type)
	{
		switch (type)
		{
		case D3D12_PRIMITIVE_TOPOLOGY_TYPE::D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE:
			return D3D12_PRIMITIVE_TOPOLOGY::D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST;
		case D3D12_PRIMITIVE_TOPOLOGY_TYPE::D3D12_PRIMITIVE_TOPOLOGY_TYPE_LINE:
			return D3D12_PRIMITIVE_TOPOLOGY::D3D10_PRIMITIVE_TOPOLOGY_LINELIST;
		default:
			return D3D12_PRIMITIVE_TOPOLOGY::D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST;
		}
		return D3D12_PRIMITIVE_TOPOLOGY::D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST;
	}

	static EShaderDateType GetShaderDataType(const char* semantic)
	{
		if (!std::strcmp(semantic, RenderConstants::kSemanticPosition)) return EShaderDateType::kFloat3;
		else if (!std::strcmp(semantic, RenderConstants::kSemanticNormal)) return EShaderDateType::kFloat3;
		else if (!std::strcmp(semantic, RenderConstants::kSemanticTangent)) return EShaderDateType::kFloat4;
		else if (!std::strcmp(semantic, RenderConstants::kSemanticColor)) return EShaderDateType::kFloat4;
		else if (!std::strcmp(semantic, RenderConstants::kSemanticTexcoord)) return EShaderDateType::kFloat2;
		else
		{
			AL_ASSERT(true, "Unsupported DXGI_FORMAT to ShaderDataType!")
				//LOG_ERROR("Unsupported DXGI_FORMAT to ShaderDataType!");
				return EShaderDateType::kBool;
		}
	}

	static EShaderDateType GetShaderDataType(DXGI_FORMAT dx_format)
	{
		switch (dx_format)
		{
		case DXGI_FORMAT_R32G32B32_FLOAT: return EShaderDateType::kFloat3;
		case DXGI_FORMAT_R32G32B32A32_FLOAT: return EShaderDateType::kFloat4;
		case DXGI_FORMAT_R32G32_FLOAT: return EShaderDateType::kFloat2;
		}
		AL_ASSERT(true, "Unsupported DXGI_FORMAT to ShaderDataType!")
			//LOG_ERROR("Unsupported DXGI_FORMAT to ShaderDataType!");
			return EShaderDateType::kBool;
	}

	namespace ALHash
	{
		template<>
		static u32 CommonRuntimeHasher(const D3D12_RASTERIZER_DESC& obj)
		{
			static Vector<D3D12_RASTERIZER_DESC> hashes;
			for (u32 i = 0; i < hashes.size(); i++)
			{
				if (std::memcmp(&hashes[i], &obj, sizeof(D3D12_RASTERIZER_DESC)) == 0)
					return i;
			}
			hashes.emplace_back(obj);
			return static_cast<u32>(hashes.size() - 1);
		}
		template<>
		static u32 CommonRuntimeHasher(const D3D12_BLEND_DESC& obj)
		{
			static Vector<D3D12_BLEND_DESC> hashes;
			for (u32 i = 0; i < hashes.size(); i++)
			{
				if (std::memcmp(&hashes[i], &obj, sizeof(D3D12_BLEND_DESC)) == 0)
					return i;
			}
			hashes.emplace_back(obj);
			return static_cast<u32>(hashes.size() - 1);
		}
		template<>
		static u32 CommonRuntimeHasher(const D3D12_DEPTH_STENCIL_DESC& obj)
		{
			static Vector<D3D12_DEPTH_STENCIL_DESC> hashes;
			for (u32 i = 0; i < hashes.size(); i++)
			{
				if (std::memcmp(&hashes[i], &obj, sizeof(D3D12_DEPTH_STENCIL_DESC)) == 0)
					return i;
			}
			hashes.emplace_back(obj);
			return static_cast<u32>(hashes.size() - 1);
		}
		template<>
		static u32 CommonRuntimeHasher(const D3D12_INPUT_LAYOUT_DESC& obj)
		{
			static Vector<D3D12_INPUT_LAYOUT_DESC> hashes;
			for (u32 i = 0; i < hashes.size(); i++)
			{
				if (std::memcmp(&hashes[i], &obj, sizeof(D3D12_INPUT_LAYOUT_DESC)) == 0)
					return i;
			}
			hashes.emplace_back(obj);
			return static_cast<u32>(hashes.size() - 1);
		}
	}

	void D3DShader::GenerateInternalPSO()
	{
		D3D12_FEATURE_DATA_ROOT_SIGNATURE featureData = {};
		featureData.HighestVersion = D3D_ROOT_SIGNATURE_VERSION_1_1;
		auto device = D3DContext::GetInstance()->GetDevice();
		if (FAILED(device->CheckFeatureSupport(D3D12_FEATURE_ROOT_SIGNATURE, &featureData, sizeof(featureData))))
		{
			featureData.HighestVersion = D3D_ROOT_SIGNATURE_VERSION_1_0;
		}
		CD3DX12_DESCRIPTOR_RANGE1 ranges[32]{};
		CD3DX12_ROOT_PARAMETER1 rootParameters[32]{};
		int cbuf_mask = 0, texture_count = 0;
		for (auto it = _bind_res_infos.begin(); it != _bind_res_infos.end(); it++)
		{
			auto& desc = it->second;
			if (desc._res_type == EBindResDescType::kCBufferAttribute) continue;
			if (desc._res_type == EBindResDescType::kConstBuffer)
			{
				if (desc._name == RenderConstants::kCBufNameSceneObject) cbuf_mask |= 0x01;
				else if (desc._name == RenderConstants::kCBufNameSceneMaterial) cbuf_mask |= 0x02;
				else if (desc._name == RenderConstants::kCBufNameSceneState) cbuf_mask |= 0x04;
			}
		}
		uint8_t root_param_index = 0;
		if (cbuf_mask & 0x01)
		{
			_bind_res_infos[RenderConstants::kCBufNameSceneObject]._bind_slot = root_param_index;
			rootParameters[root_param_index++].InitAsConstantBufferView(0u);
		}
		if (cbuf_mask & 0x02)
		{
			_bind_res_infos[RenderConstants::kCBufNameSceneMaterial]._bind_slot = root_param_index;
			rootParameters[root_param_index++].InitAsConstantBufferView(1u);
		}
		if (cbuf_mask & 0x04)
		{
			_bind_res_infos[RenderConstants::kCBufNameSceneState]._bind_slot = root_param_index;
			rootParameters[root_param_index++].InitAsConstantBufferView(2u);
		}
		for (auto it = _bind_res_infos.begin(); it != _bind_res_infos.end(); it++)
		{
			auto& desc = it->second;
			if (desc._res_type == EBindResDescType::kTexture2D)
			{
				++texture_count;
				ranges[root_param_index].Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, desc._res_slot, 0, D3D12_DESCRIPTOR_RANGE_FLAG_DATA_STATIC);
				rootParameters[root_param_index].InitAsDescriptorTable(1, &ranges[root_param_index]);
				desc._bind_slot = root_param_index;
				++root_param_index;
			}
		}
		D3D12_STATIC_SAMPLER_DESC* p_sampler = nullptr;
		uint8_t sampler_num = 0;
		if (texture_count > 0)
		{
			D3D12_STATIC_SAMPLER_DESC sampler = {};
			sampler.Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;
			sampler.AddressU = D3D12_TEXTURE_ADDRESS_MODE_BORDER;
			sampler.AddressV = D3D12_TEXTURE_ADDRESS_MODE_BORDER;
			sampler.AddressW = D3D12_TEXTURE_ADDRESS_MODE_BORDER;
			sampler.MipLODBias = 1.0;
			sampler.MaxAnisotropy = 0;
			sampler.ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
			sampler.BorderColor = D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK;
			sampler.MinLOD = 0.0f;
			sampler.MaxLOD = D3D12_FLOAT32_MAX;
			sampler.ShaderRegister = 0;
			sampler.RegisterSpace = 0;
			sampler.ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
			p_sampler = &sampler;
			++sampler_num;
		}
		D3D12_ROOT_SIGNATURE_FLAGS rootSignatureFlags =
			D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |
			D3D12_ROOT_SIGNATURE_FLAG_DENY_HULL_SHADER_ROOT_ACCESS |
			D3D12_ROOT_SIGNATURE_FLAG_DENY_DOMAIN_SHADER_ROOT_ACCESS |
			D3D12_ROOT_SIGNATURE_FLAG_DENY_GEOMETRY_SHADER_ROOT_ACCESS;
		CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC rootSignatureDesc;
		rootSignatureDesc.Init_1_1(root_param_index, rootParameters, sampler_num, p_sampler, rootSignatureFlags);
		//rootSignatureDesc.Init_1_1(root_param_count, rootParameters, 0u, nullptr, rootSignatureFlags);
		ComPtr<ID3DBlob> signature;
		ComPtr<ID3DBlob> error;
		auto [sig, pso] = _pso_sys.GetBack();
		//bool succeed = true;
		//succeed = !FAILED(D3DX12SerializeVersionedRootSignature(&rootSignatureDesc, featureData.HighestVersion, &signature, &error));
		//succeed = !FAILED(device->CreateRootSignature(0, signature->GetBufferPointer(), signature->GetBufferSize(), IID_PPV_ARGS(&sig)));
		ThrowIfFailed(D3DX12SerializeVersionedRootSignature(&rootSignatureDesc, featureData.HighestVersion, &signature, &error));
		ThrowIfFailed(device->CreateRootSignature(0, signature->GetBufferPointer(), signature->GetBufferSize(), IID_PPV_ARGS(&sig)));
		_pso_desc.InputLayout = { _vertex_input_layout, _vertex_input_num };
		_pso_desc.pRootSignature = sig.Get();
		_pso_desc.VS = CD3DX12_SHADER_BYTECODE(_p_vblob.Get());
		_pso_desc.PS = CD3DX12_SHADER_BYTECODE(_p_pblob.Get());
		_pso_desc.SampleMask = UINT_MAX;
		_pso_desc.NumRenderTargets = 1;
		_pso_desc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM;
		_pso_desc.DSVFormat = DXGI_FORMAT_D32_FLOAT;
		_pso_desc.SampleDesc.Count = 1;
		_pso_desc.SampleDesc.Quality = 0;
		_pso_desc.NodeMask = 0;
		_pso_desc.Flags = D3D12_PIPELINE_STATE_FLAG_NONE;
		_pso_desc.IBStripCutValue = D3D12_INDEX_BUFFER_STRIP_CUT_VALUE_DISABLED;
		ThrowIfFailed(device->CreateGraphicsPipelineState(&_pso_desc, IID_PPV_ARGS(&pso)));
		_pso_sys.Swap();
		//succeed = !FAILED(device->CreateGraphicsPipelineState(&_pso_desc, IID_PPV_ARGS(&pso)));
	}

	void D3DShader::LoadShaderReflection(ID3D12ShaderReflection* reflection, const EShaderType& type)
	{
		D3D12_SHADER_DESC desc{};
		reflection->GetDesc(&desc);
		switch (type)
		{
		case Ailu::EShaderType::kVertex:
		{
			if (desc.InputParameters > 10)
			{
				AL_ASSERT(true, "LayoutDesc count must less than 10");
				return;
			}
			Vector<VertexBufferLayoutDesc> vb_input_desc{};
			for (uint32_t i = 0u; i < desc.InputParameters; i++)
			{
				D3D12_SIGNATURE_PARAMETER_DESC input_desc{};
				reflection->GetInputParameterDesc(i, &input_desc);
				_vertex_input_layout[i] = D3D12_INPUT_ELEMENT_DESC{ input_desc.SemanticName, 0, GetFormatBySemanticName(input_desc.SemanticName), i, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 };
				++_vertex_input_num;
				vb_input_desc.emplace_back(VertexBufferLayoutDesc(input_desc.SemanticName, GetShaderDataType(input_desc.SemanticName), input_desc.Register));
				_semantic_seq.emplace_back(input_desc.SemanticName);
			}
			_pipeline_input_layout = VertexBufferLayout(vb_input_desc);
			for (uint32_t i = 0u; i < desc.BoundResources; i++)
			{
				D3D12_SHADER_INPUT_BIND_DESC bind_desc{};
				reflection->GetResourceBindingDesc(i, &bind_desc);
				auto res_type = bind_desc.Type;
				if (res_type == D3D_SHADER_INPUT_TYPE::D3D_SIT_CBUFFER)
				{
					_bind_res_infos.insert(std::make_pair(bind_desc.Name, ShaderBindResourceInfo{ EBindResDescType::kConstBuffer,static_cast<uint16_t>(bind_desc.BindPoint),0u,bind_desc.Name }));
				}
				else if (res_type == D3D_SHADER_INPUT_TYPE::D3D_SIT_TEXTURE)
				{
					_bind_res_infos.insert(std::make_pair(bind_desc.Name, ShaderBindResourceInfo{ EBindResDescType::kTexture2D,static_cast<uint16_t>(bind_desc.BindPoint),0u,bind_desc.Name }));
				}
				else if (res_type == D3D_SHADER_INPUT_TYPE::D3D_SIT_SAMPLER)
				{
					_bind_res_infos.insert(std::make_pair(bind_desc.Name, ShaderBindResourceInfo{ EBindResDescType::kSampler,static_cast<uint16_t>(bind_desc.BindPoint),0u,bind_desc.Name }));
				}
			}
		}
		break;
		case Ailu::EShaderType::kPixel:
		{
			for (uint32_t i = 0u; i < desc.BoundResources; i++)
			{
				D3D12_SHADER_INPUT_BIND_DESC bind_desc{};
				reflection->GetResourceBindingDesc(i, &bind_desc);
				auto res_type = bind_desc.Type;
				if (res_type == D3D_SHADER_INPUT_TYPE::D3D_SIT_CBUFFER)
				{
					_bind_res_infos.insert(std::make_pair(bind_desc.Name, ShaderBindResourceInfo{ EBindResDescType::kConstBuffer,static_cast<uint16_t>(bind_desc.BindPoint),0u,bind_desc.Name }));
				}
				else if (res_type == D3D_SHADER_INPUT_TYPE::D3D_SIT_TEXTURE)
				{
					_bind_res_infos.insert(std::make_pair(bind_desc.Name, ShaderBindResourceInfo{ EBindResDescType::kTexture2D,static_cast<uint16_t>(bind_desc.BindPoint),0u,bind_desc.Name }));
				}
				else if (res_type == D3D_SHADER_INPUT_TYPE::D3D_SIT_SAMPLER)
				{
					_bind_res_infos.insert(std::make_pair(bind_desc.Name, ShaderBindResourceInfo{ EBindResDescType::kSampler,static_cast<uint16_t>(bind_desc.BindPoint),0u,bind_desc.Name }));
				}
			}
			for (uint32_t i = 0u; i < desc.ConstantBuffers; i++)
			{
				auto cbuf = reflection->GetConstantBufferByIndex(i);
				D3D12_SHADER_BUFFER_DESC desc{};
				cbuf->GetDesc(&desc);
				for (uint32_t j = 0u; j < desc.Variables; j++)
				{
					auto variable = cbuf->GetVariableByIndex(j);
					D3D12_SHADER_VARIABLE_DESC vdesc{};
					variable->GetDesc(&vdesc);
					uint8_t offset = (uint8_t)vdesc.StartOffset;
					uint8_t size = (uint8_t)vdesc.Size;
					uint16_t variable_info = 0u;
					variable_info |= offset;
					variable_info <<= 8;
					variable_info |= size;
					auto info = ShaderBindResourceInfo{ EBindResDescType::kCBufferAttribute,variable_info,0u,vdesc.Name };
					_bind_res_infos.insert(std::make_pair(vdesc.Name, info));
				}
			}
		}
		break;
		}
	}

	void D3DShader::LoadAdditionalShaderReflection(const String& sys_path)
	{
		using namespace std;
		namespace su = StringUtils;
		namespace fs = std::filesystem;
		ifstream src(sys_path, ios::in);
		string line;
		vector<string> lines;
		List<String> cur_file_head_files{};
		String parent_path = su::SubStrRange(_src_file_path, 0, _src_file_path.find_last_of("/"));
		while (getline(src, line))
		{
			if (su::BeginWith(line, "#include"))
			{
				size_t path_start = line.find_first_of("\"");
				size_t path_end = line.find_last_of("\"");
				auto head_file = su::SubStrRange(line, path_start + 1, path_end - 1);
				_source_files.insert(parent_path + head_file);
				cur_file_head_files.emplace_back(head_file);
			}
			else if (su::BeginWith(line, "Texture2D"))
			{
				size_t name_begin = line.find_first_of("D") + 1;
				size_t name_end = line.find_first_of(":") - 1;
				String tex_name = line.substr(name_begin, name_end - name_begin);
			}
			else if (su::BeginWith(line, "TextureCube"))
			{
				size_t name_begin = line.find_last_of("e") + 1;
				size_t name_end = line.find_first_of(":") - 1;
				String tex_name = line.substr(name_begin, name_end - name_begin);
				auto it = _bind_res_infos.find(tex_name);
				if (it != _bind_res_infos.end())
				{
					it->second._res_type = EBindResDescType::kCubeMap;
				}
			}
			lines.emplace_back(line);
		}
		src.close();
		fs::path src_path(sys_path);
		fs::path pwd = src_path.parent_path();
		for (auto& head_file : cur_file_head_files)
		{
			fs::path temp = pwd;
			temp.append(head_file);
			cout << temp.string() << endl;
			LoadAdditionalShaderReflection(temp.string());
		}
	}

	uint16_t D3DShader::GetVariableOffset(const std::string& name) const
	{
		//auto it = _variable_offset.find(name);
		//if (it == _variable_offset.end())
		//{
		//	//LOG_WARNING("variable: {} don't exist in shader: {}", name, _name);
		//	return 0;
		//}
		//return it->second;
		return 0;
	}

	D3DShader::D3DShader(const std::string& sys_path, const std::string_view shader_name, const uint32_t& id, EShaderType type)
	{

	}

	D3DShader::D3DShader(const std::string& sys_path, const std::string_view shader_name, const uint32_t& id) : _name(shader_name), _id(id)
	{
		if (!_b_init_buffer)
		{
			m_cbvHeap = D3DContext::GetInstance()->GetDescriptorHeap();
			_desc_size = D3DContext::GetInstance()->GetDevice()->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
			_p_cbuffer = D3DContext::GetInstance()->GetCBufferPtr();
			_b_init_buffer = true;
		}
		_src_file_path = sys_path;
		_source_files.insert(sys_path);
		//#if defined(_DEBUG)
		//		// Enable better shader debugging with the graphics debugging tools.
		//		UINT compileFlags = D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION;
		//#else
		//		UINT compileFlags = 0;
		//#endif
		Compile();
	}

	D3DShader::~D3DShader()
	{
		for (auto p : _keyword_defines)
		{
			DESTORY_PTRARR(p);
		}
	}

	std::pair<D3D12_INPUT_ELEMENT_DESC*, uint8_t> D3DShader::GetVertexInputLayout()
	{
		return std::make_pair(_vertex_input_layout, _vertex_input_num);
	}

	void D3DShader::AddMaterialRef(Material* mat)
	{
		_reference_mats.insert(mat);
	}

	void D3DShader::RemoveMaterialRef(Material* mat)
	{
		_reference_mats.erase(mat);
	}

	void D3DShader::ParserShaderProperty(String& line, List<ShaderPropertyInfo>& props)
	{
		line = su::Trim(line);
		String addi_info{};
		if (line.find("[") != line.npos)
		{
			auto begin = line.find("["), end = line.find("]");
			addi_info = su::SubStrRange(line, begin + 1, end - 1);
			line = line.substr(end + 1);
			line = su::Trim(line);
		}
		auto cur_edge = line.find_first_of("(");
		String value_name = line.substr(0, cur_edge);
		line = line.substr(cur_edge);
		cur_edge = line.find_first_of("=");
		String defalut_value = line.substr(cur_edge + 1);
		line = line.substr(0, cur_edge - 1);
		su::RemoveSpaces(defalut_value);
		line = line.substr(1, line.find_last_of(")") - 1);
		cur_edge = line.find_first_of(",");
		String prop_name = line.substr(1, cur_edge - 2);
		String prop_type = line.substr(cur_edge + 1);
		ESerializablePropertyType seri_type;
		if (prop_type == "Texture2D") seri_type = ESerializablePropertyType::kTexture2D;
		else if (prop_type == "Color") seri_type = ESerializablePropertyType::kColor;
		else if (*(prop_type.begin()) == *"R") seri_type = ESerializablePropertyType::kRange;
		else if (prop_type == GetSerializablePropertyTypeStr(ESerializablePropertyType::kFloat)) seri_type = ESerializablePropertyType::kFloat;
		else if (prop_type == "Vector") seri_type = ESerializablePropertyType::kVector4f;
		else seri_type = ESerializablePropertyType::kUndefined;
		if (!addi_info.empty())
		{
			if (addi_info.starts_with("Toggle"))
			{
				seri_type = ESerializablePropertyType::kBool;
				_keywords[value_name].emplace_back(value_name + "_ON");
				_keywords[value_name].emplace_back(value_name + "_OFF");
			}
			else if (addi_info.starts_with("Enum"))
			{
				seri_type = ESerializablePropertyType::kEnum;
				auto enum_strs = su::Split(su::SubStrRange(addi_info, addi_info.find("(") + 1, addi_info.find(")") - 1), ",");
				_keywords[value_name].resize(enum_strs.size() / 2);
				for (size_t i = 0; i < enum_strs.size(); i += 2)
				{
					_keywords[value_name][std::stoi(enum_strs[i + 1])] = value_name + "_" + enum_strs[i];
				}
			}
		}
		Vector4f prop_param;
		if (seri_type == ESerializablePropertyType::kRange)
		{
			cur_edge = prop_type.find_first_of(",");
			size_t left_bracket = prop_type.find_first_of("(");
			size_t right_bracket = prop_type.find_first_of(")");
			prop_param.x = static_cast<float>(std::stod(su::SubStrRange(prop_type, left_bracket + 1, cur_edge - 1)));
			prop_param.y = static_cast<float>(std::stod(su::SubStrRange(prop_type, cur_edge + 1, right_bracket - 1)));
			prop_param.z = static_cast<float>(std::stod(defalut_value));
		}
		else if (seri_type == ESerializablePropertyType::kFloat || seri_type == ESerializablePropertyType::kBool)
		{
			prop_param.z = static_cast<float>(std::stod(defalut_value));
		}
		else if (seri_type == ESerializablePropertyType::kColor || seri_type == ESerializablePropertyType::kVector4f)
		{
			defalut_value = su::SubStrRange(defalut_value, 1, defalut_value.find_first_of(")") - 1);
			auto vec_str = su::Split(defalut_value, ",");
			prop_param.x = static_cast<float>(std::stod(vec_str[0]));
			prop_param.y = static_cast<float>(std::stod(vec_str[1]));
			prop_param.z = static_cast<float>(std::stod(vec_str[2]));
			prop_param.w = static_cast<float>(std::stod(vec_str[3]));
		}
		if (seri_type != ESerializablePropertyType::kUndefined)
		{
			props.emplace_back(ShaderPropertyInfo{ value_name ,prop_name,seri_type ,prop_param });
			LOG_INFO("prop name: {},default value {}", prop_name, defalut_value);
		}
		else
		{
			g_pLogMgr->LogWarningFormat("Undefined shader property type with name {}", prop_name);
		}

	}

	struct ShaderCommand
	{
		inline static const String kName = "name";
		inline static const String kVSEntry = "Vert";
		inline static const String kPSEntry = "Pixel";
		inline static const String kCull = "Cull";
		inline static const String kQueue = "Queue";
		inline static const String kTopology = "Topology";
		inline static const String kBlend = "Blend";
		inline static const String KFill = "Fill";
		static struct Queue
		{
			inline static const String kGeometry = "Geometry";
			inline static const String kTransplant = "Transparent";
		} kQueueValue;
		static struct Cull
		{
			inline static const String kNone = "none";
			inline static const String kFront = "Front";
			inline static const String kBack = "Back";
		} kCullValue;
		static struct Topology
		{
			inline static const String kTriangle = "Triangle";
			inline static const String kLine = "Line";
		} kTopologyValue;
		static struct BlendFactor
		{
			inline static const String kSrc = "Src";
			inline static const String kOneMinusSrc = "OneMinusSrc";
			inline static const String kOne = "One";
			inline static const String kZero = "Zero";
		} kBlendFactorValue;
		static struct Fill
		{
			inline static const String kSolid = "Solid";
			inline static const String kWireframe = "Wireframe";
		} kFillValue;
	};

	void D3DShader::PreProcessShader()
	{
		Vector<Vector<String>> kw_permutation_in{};
		int kw_group_count = 0;
		for (auto& it : _keywords)
		{
			Vector<String> v;
			for (int i = 0; i < it.second.size(); i++)
			{
				auto& kw = it.second[i];
				_keywords_ids[kw] = std::make_tuple(kw_group_count, i);
				v.emplace_back(kw);
			}
			++kw_group_count;
			kw_permutation_in.emplace_back(v);
		}
		if (!kw_permutation_in.empty())
		{
			for (auto& kw_seq : Algorithm::Permutations(kw_permutation_in))
			{
				u64 kw_hash = 0;
				u64 temp_hash = 0;
				D3D_SHADER_MACRO* shader_marcos = new D3D_SHADER_MACRO[kw_seq.size() + 1];
				for (int i = 0; i < kw_seq.size(); i++)
				{
					auto& [group_id, inner_id] = _keywords_ids[kw_seq[i]];
					temp_hash = inner_id;
					temp_hash <<= group_id * 3;//每个关键字组占三位，也就是每组内最多8个关键字
					kw_hash |= temp_hash;
					shader_marcos[i] = { kw_seq[i].c_str(),"1" };
				}
				shader_marcos[kw_seq.size()] = { NULL,NULL };
				_keyword_defines.emplace_back(shader_marcos);
			}
		}
	}

	void D3DShader::LoadAdditionInfo()
	{
		memset(&_pso_desc, 0, sizeof(D3D12_GRAPHICS_PIPELINE_STATE_DESC));
		D3D12_RASTERIZER_DESC r_desc = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);
		D3D12_BLEND_DESC bl_desc = CD3DX12_BLEND_DESC(D3D12_DEFAULT);
		D3D12_DEPTH_STENCIL_DESC ds_desc = CD3DX12_DEPTH_STENCIL_DESC(CD3DX12_DEFAULT{});
		_pso_desc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE::D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
		List<String> lines{};
		String line{};
		u32 line_count = 0;
		lines = ReadFileToLines(_src_file_path, line_count, "//info bein", "//info end");
		if (line_count > 0)
		{
			auto prop_start_it = std::find(lines.begin(), lines.end(), "//Properties");
			auto prop_end_it = std::find(prop_start_it, lines.end(), "//}");
			if (prop_start_it != lines.end())
			{
				prop_start_it++;
				prop_start_it++;
				for (auto& it = prop_start_it; it != prop_end_it; it++)
				{
					line = it->substr(2);
					ParserShaderProperty(line, _shader_prop_infos);
				}
				prop_start_it--;
				prop_start_it--;
			}
			String k, v, blend_info;
			bool is_transparent = false;
			for (auto it = lines.begin(); it != prop_start_it; it++)
			{
				line = it->substr(2);
				k = line.substr(0, line.find_first_of(":"));
				su::RemoveSpaces(k);
				v = line.substr(line.find_first_of(":") + 1);
				su::RemoveSpaces(v);
				if (su::Equal(k, ShaderCommand::kName, false)) _name = v;
				else if (su::Equal(k, ShaderCommand::kVSEntry, false)) _vert_entry = v;
				else if (su::Equal(k, ShaderCommand::kPSEntry, false)) _pixel_entry = v;
				else if (su::Equal(k, ShaderCommand::kCull, false))
				{
					if (su::Equal(v, ShaderCommand::kCullValue.kBack, false))
					{
						_pipeline_raster_state._cull_mode = ECullMode::kBack;
						r_desc.CullMode = D3D12_CULL_MODE_BACK;
					}
					else
					{
						_pipeline_raster_state._cull_mode = ECullMode::kFront;
						r_desc.CullMode = D3D12_CULL_MODE_FRONT;
					}
				}
				else if (su::Equal(k, ShaderCommand::kTopology, false))
				{
					if (su::Equal(v, ShaderCommand::kTopologyValue.kLine))
					{
						_pso_desc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_LINE;
						_pipeline_topology = ETopology::kLine;
					}
				}
				else if (su::Equal(k, ShaderCommand::kBlend, false))
				{
					blend_info = v;
				}
				else if (su::Equal(k, ShaderCommand::kQueue, false))
				{
					if (su::Equal(v, ShaderCommand::kQueueValue.kTransplant, false))
						is_transparent = true;
				}
				else if (su::Equal(k, ShaderCommand::KFill, false))
				{
					if (su::Equal(v, ShaderCommand::kFillValue.kWireframe))
					{
						r_desc.FillMode = D3D12_FILL_MODE_WIREFRAME;
						_pipeline_raster_state._fill_mode = EFillMode::kWireframe;
					}
				}
				else {}
			}
			if (is_transparent && !blend_info.empty())
			{
				auto blend_factors = su::Split(blend_info, ",");
				static auto get_d3d_blend_factor = [](const String& s) -> D3D12_BLEND {
					if (su::Equal(s, ShaderCommand::kBlendFactorValue.kOne)) return D3D12_BLEND::D3D12_BLEND_ONE;
					else if (su::Equal(s, ShaderCommand::kBlendFactorValue.kZero)) return D3D12_BLEND::D3D12_BLEND_ZERO;
					else if (su::Equal(s, ShaderCommand::kBlendFactorValue.kSrc)) return D3D12_BLEND::D3D12_BLEND_SRC_ALPHA;
					else if (su::Equal(s, ShaderCommand::kBlendFactorValue.kOneMinusSrc)) return D3D12_BLEND::D3D12_BLEND_INV_SRC_ALPHA;
					else return D3D12_BLEND::D3D12_BLEND_ONE;
					};
				static auto get_ailu_blend_factor = [](const String& s) -> EBlendFactor {
					if (su::Equal(s, ShaderCommand::kBlendFactorValue.kOne)) return EBlendFactor::kOne;
					else if (su::Equal(s, ShaderCommand::kBlendFactorValue.kZero)) return EBlendFactor::kZero;
					else if (su::Equal(s, ShaderCommand::kBlendFactorValue.kSrc)) return EBlendFactor::kSrcAlpha;
					else if (su::Equal(s, ShaderCommand::kBlendFactorValue.kOneMinusSrc)) return EBlendFactor::kOneMinusSrcAlpha;
					else return EBlendFactor::kOne;
					};
				_pipeline_blend_state._b_enable = true;
				_pipeline_blend_state._src_color = get_ailu_blend_factor(blend_factors[0]);
				_pipeline_blend_state._dst_color = get_ailu_blend_factor(blend_factors[1]);
				bl_desc = D3DConvertUtils::ConvertToD3D12BlendDesc(_pipeline_blend_state,1);
				//bl_desc.RenderTarget[0] = D3DConvertUtils::ConvertToD3D12BlendDesc(_pipeline_blend_state);
				//bl_desc.RenderTarget[0].BlendEnable = true;
				//bl_desc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
				//bl_desc.RenderTarget[0].SrcBlend = get_d3d_blend_factor(blend_factors[0]);
				//bl_desc.RenderTarget[0].DestBlend = get_d3d_blend_factor(blend_factors[1]);
			}
			for (auto& it = prop_end_it; it != lines.end(); it++)
			{
				line = it->substr(2);
				if (line.find("multi") != line.npos)
				{
					//format: groupname_keywordname
					auto keywords_str = line.substr(line.find_first_of("e") + 1);
					keywords_str = su::Trim(keywords_str);
					auto kw_seq = su::Split(keywords_str, " ");
					if (kw_seq.size() > 0)
					{
						String kw_group_name = kw_seq[0].substr(0, kw_seq[0].rfind("_"));
						for (auto& kw : kw_seq)
						{
							if (std::find(_keywords[kw_group_name].begin(), _keywords[kw_group_name].end(), kw) == _keywords[kw_group_name].end())
								_keywords[kw_group_name].emplace_back(kw);
						}
					}
				}
			}
		}
		else
		{
			g_pLogMgr->LogErrorFormat("PreProcess shader: {} with line count 0", _src_file_path);
		}
		//_pso_desc.RasterizerState = r_desc;
		//_pso_desc.BlendState = bl_desc;
		//_pso_desc.DepthStencilState = ds_desc;
		_pso_desc.RasterizerState = D3DConvertUtils::ConvertToD3D12RasterizerDesc(_pipeline_raster_state);
		_pso_desc.BlendState = D3DConvertUtils::ConvertToD3D12BlendDesc(_pipeline_blend_state);
		_pso_desc.DepthStencilState = D3DConvertUtils::ConvertToD3D12DepthStencilDesc(_pipeline_ds_state);
		_topology = ConvertTopologyToType(_pso_desc.PrimitiveTopologyType);
	}

	void D3DShader::Reset()
	{
		if (_p_vblob != nullptr) _p_vblob->Release();
		if (_p_pblob != nullptr) _p_pblob->Release();
		if (_p_v_reflection != nullptr) _p_v_reflection->Release();
		if (_p_p_reflection != nullptr) _p_p_reflection->Release();
		_vertex_input_num = 0u;
		memset(_vertex_input_layout, 0, sizeof(D3D12_INPUT_ELEMENT_DESC) * RenderConstants::kMaxVertexAttrNum);
		_variable_offset.clear();
		//_pipeline_raster_state = RasterizerState();
		//_pipeline_ds_state;
		//_pipeline_blend_state;
		_pipeline_topology = ETopology::kTriangle;
	}

	const List<ShaderPropertyInfo>& D3DShader::GetShaderPropertyInfos() const
	{
		return _shader_prop_infos;
	}

	uint8_t* D3DShader::GetCBufferPtr(uint32_t index)
	{
		if (index > RenderConstants::kMaxMaterialDataCount)
		{
			AL_ASSERT(true, "Material num more than MaxMaterialDataCount!");
			return nullptr;
		}
		return _p_cbuffer + RenderConstants::kPerFrameDataSize + index * RenderConstants::kPerMaterialDataSize;
	}

	void D3DShader::Bind()
	{
		auto cmdlist = D3DContext::GetInstance()->GetCmdList();
		_pso_sys.Bind(cmdlist);
		cmdlist->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
		if (_per_mat_buf_bind_slot == -1) return;
		D3D12_GPU_DESCRIPTOR_HANDLE matHandle;
		matHandle.ptr = m_cbvHeap->GetGPUDescriptorHandleForHeapStart().ptr + _desc_size;
		cmdlist->SetGraphicsRootDescriptorTable(_per_mat_buf_bind_slot, matHandle);
	}

	void D3DShader::Bind(uint32_t index)
	{
		if (index > RenderConstants::kMaxMaterialDataCount)
		{
			AL_ASSERT(true, "Material num more than MaxMaterialDataCount!");
			return;
		}
		static auto cmdlist = D3DContext::GetInstance()->GetCmdList();
		static auto context = D3DContext::GetInstance();
		_pso_sys.Bind(cmdlist);
		cmdlist->IASetPrimitiveTopology(_topology);
		if (_per_mat_buf_bind_slot != -1)
			cmdlist->SetGraphicsRootConstantBufferView(_per_mat_buf_bind_slot, context->GetCBufferViewDesc(1 + index).BufferLocation);
		if (_per_frame_buf_bind_slot != -1)
			cmdlist->SetGraphicsRootConstantBufferView(_per_frame_buf_bind_slot, context->GetCBufferViewDesc(0).BufferLocation);
	}

	inline std::string D3DShader::GetName() const
	{
		return _name;
	}

	inline uint32_t D3DShader::GetID() const
	{
		return _id;
	}

	inline const std::unordered_map<std::string, ShaderBindResourceInfo>& D3DShader::GetBindResInfo() const
	{
		return _bind_res_infos;
	}

	bool D3DShader::Compile()
	{
		ComPtr<ID3D12ShaderReflection> _tmp_p_v_reflection;
		ComPtr<ID3D12ShaderReflection> _tmp_p_p_reflection;
		ComPtr<ID3DBlob> _tmp_p_vblob = nullptr;
		ComPtr<ID3DBlob> _tmp_p_pblob = nullptr;
		bool succeed = true;
		try
		{
#ifdef SHADER_DXC
			CreateFromFileDXC(ToWChar(file_name.data()), L"VSMain", D3DConstants::kVSModel_6_1, _p_vblob, _p_reflection);
			LoadShaderReflection(_p_reflection.Get());
			CreateFromFileDXC(ToWChar(file_name.data()), L"PSMain", D3DConstants::kPSModel_6_1, _p_pblob, _p_reflection);
			LoadShaderReflection(_p_reflection.Get());
#else
			succeed &= CreateFromFileFXC(ToWChar(_src_file_path.data()), "VSMain", "vs_5_0", _tmp_p_vblob, _tmp_p_v_reflection);
			succeed &= CreateFromFileFXC(ToWChar(_src_file_path.data()), "PSMain", "ps_5_0", _tmp_p_pblob, _tmp_p_p_reflection);
#endif // SHADER_DXC
		}
		catch (const std::exception&)
		{
			succeed = false;
			g_pLogMgr->LogErrorFormat("Compile shader with src {0} failed!", _src_file_path);
			return false;
		}
		is_error = !succeed;
		if (succeed)
		{
			Reset();
			PreProcessShader();
			LoadShaderReflection(_tmp_p_v_reflection.Get(), EShaderType::kVertex);
			LoadShaderReflection(_tmp_p_p_reflection.Get(), EShaderType::kPixel);
			LoadAdditionInfo();
			//{
			//	auto it = _shader_prop_infos.begin();
			//	while (it != _shader_prop_infos.end())
			//	{
			//		if (!_bind_res_infos.contains(it->_value_name))
			//		{
			//			it = _shader_prop_infos.erase(it);
			//		}
			//		else
			//			it++;
			//	}
			//}
			LoadAdditionalShaderReflection(_src_file_path);
			_p_vblob = _tmp_p_vblob;
			_p_pblob = _tmp_p_pblob;
			_p_v_reflection = _tmp_p_v_reflection;
			_p_p_reflection = _tmp_p_p_reflection;
			GenerateInternalPSO();
			auto it = _bind_res_infos.find(RenderConstants::kCBufNameSceneMaterial);
			if (it != _bind_res_infos.end()) _per_mat_buf_bind_slot = it->second._bind_slot;
			it = _bind_res_infos.find(RenderConstants::kCBufNameSceneState);
			if (it != _bind_res_infos.end()) _per_frame_buf_bind_slot = it->second._bind_slot;
			return true;
		}
		return false;
	}

	void D3DShader::SetGlobalVector(const std::string& name, const Vector4f& vector)
	{
		auto it = _variable_offset.find(name);
		if (it == _variable_offset.end())
		{
			//LOG_WARNING("variable: {} don't exist in shader: {}",name,_name);
			return;
		}
		memcpy(_p_cbuffer + GetPerFramePropertyOffset(name), &vector, sizeof(vector));
	}

	void D3DShader::SetGlobalVector(const std::string& name, const Vector3f& vector)
	{
	}

	void D3DShader::SetGlobalVector(const std::string& name, const Vector2f& vector)
	{
	}

	void D3DShader::SetGlobalMatrix(const std::string& name, const Matrix4x4f& mat)
	{
		memcpy(_p_cbuffer + GetPerFramePropertyOffset(name), &mat, sizeof(mat));
	}

	void D3DShader::SetGlobalMatrix(const std::string& name, const Matrix3x3f& mat)
	{
	}

	const Vector<String>& D3DShader::GetVSInputSemanticSeqences() const
	{
		return _semantic_seq;
	}

	Vector<Material*> D3DShader::GetAllReferencedMaterials()
	{
		Vector<Material*> ret;
		ret.reserve(_reference_mats.size());
		for (auto it = _reference_mats.begin(); it != _reference_mats.end(); it++)
			ret.emplace_back(*it);
		return ret;
	}

	const std::set<String>& D3DShader::GetSourceFiles() const
	{
		return _source_files;
	}

	Vector4f D3DShader::GetVectorValue(const std::string& name)
	{
		auto it = _bind_res_infos.find(name);
		if (it != _bind_res_infos.end())
		{
			return *reinterpret_cast<Vector4f*>(_p_cbuffer + ShaderBindResourceInfo::GetVariableOffset(it->second));
		}
		else
		{
			g_pLogMgr->LogWarningFormat("Get vector: {} on shader: {} failed!", name, _name);
			return Vector4f::Zero;
		}
	}

	float D3DShader::GetFloatValue(const std::string& name)
	{
		auto it = _bind_res_infos.find(name);
		if (it != _bind_res_infos.end())
		{
			return *reinterpret_cast<float*>(_p_cbuffer + ShaderBindResourceInfo::GetVariableOffset(it->second));
		}
		else
		{
			g_pLogMgr->LogWarningFormat("Get float: {} on shader: {} failed!", name, _name);
			return 0.0f;
		}
	}

	void* D3DShader::GetByteCode(EShaderType type)
	{
		switch (type)
		{
		case Ailu::EShaderType::kVertex:
			return reinterpret_cast<void*>(_p_vblob.Get());
		case Ailu::EShaderType::kPixel:
			return reinterpret_cast<void*>(_p_pblob.Get());
		}
		return nullptr;
	}

	const String& D3DShader::GetSrcPath() const
	{
		return _src_file_path;
	}

	ID3D12RootSignature* D3DShader::GetSignature()
	{
		auto [sig, pso] = _pso_sys.GetFront();
		return sig.Get();
	}
	ID3D12ShaderReflection* D3DShader::GetD3DReflectionInfo() const
	{
		return _p_p_reflection.Get();
	}
	ID3D12ShaderReflection* D3DShader::GetD3DReflectionInfo(const EShaderType& type) const
	{
		switch (type)
		{
		case Ailu::EShaderType::kVertex:
			return _p_v_reflection.Get();
		case Ailu::EShaderType::kPixel:
			return _p_p_reflection.Get();
		}
		LOG_ERROR("Unsupported type shader reflection info!");
		return nullptr;
	}
}

#include "pch.h"
//#include <atlcomcli.h>
#include <d3dcompiler.h>
#include <dxcapi.h>
#include <mutex>

#include "Framework/Common/Application.h"
#include "Framework/Common/FileManager.h"
#include "Framework/Common/Log.h"
#include "Framework/Common/ResourceMgr.h"
#include "Framework/Common/Utils.h"
#include "GlobalMarco.h"
#include "RHI/DX12/D3DCommandBuffer.h"
#include "RHI/DX12/D3DContext.h"
#include "RHI/DX12/D3DShader.h"
#include "RHI/DX12/D3DTexture.h"
#include "RHI/DX12/dxhelper.h"
#include "Render/GraphicsPipelineStateObject.h"


namespace Ailu
{
    class D3DShaderInclude : public ID3DInclude
    {
        HRESULT Open(D3D_INCLUDE_TYPE IncludeType, LPCSTR pFileName, LPCVOID pParentData, LPCVOID *ppData, UINT *pBytes) override;

        HRESULT Close(LPCVOID pData) override;

    public:
        WString _cur_source_file_path;
        std::set<WString> _include_files;

    private:
        List<WString> _addi_include_pathes = {
                L"Shaders/",
                L"Shaders/hlsl/",
                L"Shaders/hlsl/Compute/",
                L"Shaders/hlsl/PostProcess/"};
        u8 *_data;
        inline static std::mutex s_compile_lock;
    };

    //shader model 6.0 and higher,can't see cbuffer info in PIX!!!!
    static bool CreateFromFileDXC(const std::wstring &filename, const std::wstring &entryPoint, const std::wstring &pTarget, ComPtr<ID3DBlob> &p_blob,
                                  ComPtr<ID3D12ShaderReflection> &shader_reflection)
    {
        //CComPtr
        ComPtr<IDxcUtils> pUtils;
        ComPtr<IDxcCompiler3> pCompiler;
        DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(&pUtils));
        DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&pCompiler));

        ComPtr<IDxcIncludeHandler> pIncludeHandler;
        pUtils->CreateDefaultIncludeHandler(&pIncludeHandler);

        LOG_INFO(filename.c_str());
        LOG_INFO(entryPoint.c_str());
        LOG_INFO(pTarget.c_str());

        LPCWSTR pszArgs[] =
                {
                        filename.c_str(),         // Optional shader source file name for error reporting and for PIX shader source view.
                        L"-E", entryPoint.c_str(),// Entry point.
                        L"-T", pTarget.c_str(),   // Target.
                        L"-Zi",                   // Enable debug information.
                        L"-D", L"MYDEFINE=1",     // A single define.
                        L"-Fo", L"myshader.bin",  // Optional. Stored in the pdb.
                        L"-Fd", L"myshader.pdb",  // The file name of the pdb. This must either be supplied or the autogenerated file name must be used.
                        L"-Qstrip_reflect",       // Strip reflection into a separate blob.
                };


        ComPtr<IDxcBlobEncoding> pSource = nullptr;
        pUtils->LoadFile(filename.c_str(), nullptr, &pSource);
        DxcBuffer Source;
        Source.Ptr = pSource->GetBufferPointer();
        Source.Size = pSource->GetBufferSize();
        Source.Encoding = DXC_CP_ACP;// Assume BOM says UTF8 or UTF16 or this is ANSI text.

        //
        // Compile it with specified arguments.
        //
        ComPtr<IDxcResult> pResults;
        pCompiler->Compile(
                &Source,               // Source buffer.
                pszArgs,               // Array of pointers to arguments.
                _countof(pszArgs),     // Number of arguments.
                pIncludeHandler.Get(), // User-provided interface to handle #include directives (optional).
                IID_PPV_ARGS(&pResults)// Compiler output status, buffer, and errors.
        );

        //
        // Print errors if present.
        //
        ComPtr<IDxcBlobUtf8> pErrors = nullptr;
        pResults->GetOutput(DXC_OUT_ERRORS, IID_PPV_ARGS(&pErrors), nullptr);
        // Note that d3dcompiler would return null if no errors or warnings are present.
        // IDxcCompiler3::Compile will always return an error buffer, but its length will be zero if there are no warnings or errors.
        if (pErrors != nullptr && pErrors->GetStringLength() != 0)
            LOG_ERROR("{}", pErrors->GetStringPointer());

        //
        // Quit if the compilation failed.
        //
        HRESULT hrStatus;
        pResults->GetStatus(&hrStatus);
        if (FAILED(hrStatus))
        {
            LOG_ERROR("Compilation Failed");
            return false;
        }

        //
        // Save shader binary.
        //
        ComPtr<IDxcBlob> pShader = nullptr;
        ComPtr<IDxcBlobUtf16> pShaderName = nullptr;
        pResults->GetOutput(DXC_OUT_OBJECT, IID_PPV_ARGS(&p_blob), &pShaderName);

        ComPtr<IDxcBlob> pReflectionData;
        pResults->GetOutput(DXC_OUT_REFLECTION, IID_PPV_ARGS(&pReflectionData), nullptr);
        if (pReflectionData != nullptr)
        {
            // Optionally, save reflection blob for later here.

            // Create reflection interface.
            DxcBuffer ReflectionData;
            ReflectionData.Encoding = DXC_CP_ACP;
            ReflectionData.Ptr = pReflectionData->GetBufferPointer();
            ReflectionData.Size = pReflectionData->GetBufferSize();
            pUtils->CreateReflection(&ReflectionData, IID_PPV_ARGS(shader_reflection.GetAddressOf()));
        }
        return true;
    }

    static bool CreateFromFileFXC(const std::wstring &filename, const std::string &entryPoint, const std::string &pTarget, const Vector<D3D_SHADER_MACRO> &keywords, ComPtr<ID3DBlob> &p_blob,
                                  ComPtr<ID3D12ShaderReflection> &shader_reflection, std::set<WString> &include_files, bool is_load_cache = true)
    {
        D3DShaderInclude include;
        include._cur_source_file_path = filename;
        Vector<String> keyword_str;
        for (auto &kw: keywords)
        {
            if (kw.Name != nullptr)
                keyword_str.emplace_back(kw.Name);
        }
        String unique_str = std::format("{}_{}_{}", ToChar(filename), entryPoint, su::Join(keyword_str, "_"));
        std::hash<String> hash_fn;
        u64 shader_hash = hash_fn(unique_str);
        auto working_path = Application::GetWorkingPath();
        WString cached_blob_path = working_path + std::format(L"cache/shader_cache/hlsl/{}.cso", shader_hash);
        if (is_load_cache && FileManager::Exist(cached_blob_path) && FileManager::IsFileNewer(cached_blob_path, filename))
        {
            LOG_INFO(L"[D3DShader compiler]: load cache: {},entry : {}", filename, ToWStr(entryPoint));
            ThrowIfFailed(D3DReadFileToBlob(cached_blob_path.c_str(), p_blob.GetAddressOf()));
        }
        else
        {
            LOG_INFO(L"[D3DShader compiler]: compile : {},entry : {}", filename, ToWStr(entryPoint));
            ID3DBlob *pErrorBlob = nullptr;
            //D3D_SHADER_MACRO macros[] = { {"D3D_COMPILE","1"},{NULL,NULL} };
            UINT compileFlags = 0;
#if defined(_DEBUG)
            if (pTarget == RenderConstants::kCSModel_5_0)
            {
                compileFlags = D3DCOMPILE_DEBUG | D3DCOMPILE_DEBUG_NAME_FOR_SOURCE | D3DCOMPILE_SKIP_OPTIMIZATION;//跳过优化的话，compute shader算brdf lut时值有点异常
            }
            else
            {
                // Enable better shader debugging with the graphics debugging tools.
                compileFlags = D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION | D3DCOMPILE_DEBUG_NAME_FOR_SOURCE;
            }
#else
            compileFlags = 0;
#endif
            D3DCompileFromFile(filename.c_str(), keywords.data(), &include, entryPoint.c_str(), pTarget.c_str(), compileFlags, 0, &p_blob, &pErrorBlob);
            if (pErrorBlob)
            {
                //OutputDebugStringA(reinterpret_cast<const char*>(pErrorBlob->GetBufferPointer()));
                String text(reinterpret_cast<const char *>(pErrorBlob->GetBufferPointer()));
                // 使用 std::stringstream 分割文本并提取每一行
                std::istringstream iss(text);
                //std::vector<std::string> lines;
                std::string line;
                while (std::getline(iss, line))
                {
                    if (line.find("ERROR") != line.npos || line.find("error") != line.npos)
                    {
                        LOG_ERROR("{} when compile shader {}", line, ToChar(filename))
                    }
                }
                pErrorBlob->Release();
            }
            if (p_blob != nullptr)
                FileManager::WriteFile(cached_blob_path, false, (u8 *) p_blob->GetBufferPointer(), p_blob->GetBufferSize());
        }

        if (p_blob != nullptr)
        {
            /*
            ComPtr<ID3DBlob> pPDB;
            D3DGetBlobPart(p_blob->GetBufferPointer(), p_blob->GetBufferSize(), D3D_BLOB_PDB, 0, pPDB.GetAddressOf());
            // Now retrieve the suggested name for the debug data file:
            ComPtr<ID3DBlob> pPDBName;
            D3DGetBlobPart(p_blob->GetBufferPointer(), p_blob->GetBufferSize(), D3D_BLOB_DEBUG_NAME, 0, pPDBName.GetAddressOf());
            // This struct represents the first four bytes of the name blob:
            struct ShaderDebugName
            {
                uint16_t Flags;     // Reserved, must be set to zero.
                uint16_t NameLength;// Length of the debug name, without null terminator.
                                    // Followed by NameLength bytes of the UTF-8-encoded name.
                                    // Followed by a null terminator.
                                    // Followed by [0-3] zero bytes to align to a 4-byte boundary.
            };

            auto pDebugNameData = reinterpret_cast<const ShaderDebugName *>(pPDBName->GetBufferPointer());
            auto pName = reinterpret_cast<const char *>(pDebugNameData + 1);
            // Now write the contents of the blob pPDB to a file named the value of pName
            // Not illustrated here
            WString p = ResourceMgr::GetResSysPath(L"ShaderPDB/" + ToWStr(pName));
            FileManager::CreateFile(p);
            FileManager::WriteFile(p, false, (u8*)p_blob->GetBufferPointer(), p_blob->GetBufferSize());
            // Now remove the debug info from the target shader, resulting in a smaller shader
            // in your final application’s data:
            //ComPtr<ID3DBlob> pStripped;
            //D3DStripShader(p_blob->GetBufferPointer(), p_blob->GetBufferSize(), D3DCOMPILER_STRIP_DEBUG_INFO, pStripped.GetAddressOf());
            // Finally, write the contents of pStripped as your final shader file.
            */

            ID3D12ShaderReflection *pReflection = NULL;
            D3DReflect(p_blob->GetBufferPointer(), p_blob->GetBufferSize(), IID_ID3D12ShaderReflection, (void **) &shader_reflection);
            for (auto &p: include._include_files)
                include_files.insert(p);
            return true;
        }
        return false;
    }

    static D3D12_PRIMITIVE_TOPOLOGY ConvertTopologyToType(D3D12_PRIMITIVE_TOPOLOGY_TYPE type)
    {
        switch (type)
        {
            case D3D12_PRIMITIVE_TOPOLOGY_TYPE::D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE:
                return D3D12_PRIMITIVE_TOPOLOGY::D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST;
            case D3D12_PRIMITIVE_TOPOLOGY_TYPE::D3D12_PRIMITIVE_TOPOLOGY_TYPE_LINE:
                return D3D12_PRIMITIVE_TOPOLOGY::D3D10_PRIMITIVE_TOPOLOGY_LINELIST;
            default:
                return D3D12_PRIMITIVE_TOPOLOGY::D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST;
        }
        return D3D12_PRIMITIVE_TOPOLOGY::D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST;
    }

    static EShaderDateType GetShaderDataType(DXGI_FORMAT dx_format)
    {
        switch (dx_format)
        {
            case DXGI_FORMAT_R32G32B32_FLOAT:
                return EShaderDateType::kFloat3;
            case DXGI_FORMAT_R32G32B32A32_FLOAT:
                return EShaderDateType::kFloat4;
            case DXGI_FORMAT_R32G32_FLOAT:
                return EShaderDateType::kFloat2;
        }
        AL_ASSERT_MSG(false, "Unsupported DXGI_FORMAT to ShaderDataType!");
        //LOG_ERROR("Unsupported DXGI_FORMAT to ShaderDataType!");
        return EShaderDateType::kBool;
    }

    static const Vector<CD3DX12_STATIC_SAMPLER_DESC> &CreateStaticSampler()
    {
        static Vector<CD3DX12_STATIC_SAMPLER_DESC> samplers{
                CD3DX12_STATIC_SAMPLER_DESC(0, D3D12_FILTER_MIN_MAG_MIP_LINEAR, D3D12_TEXTURE_ADDRESS_MODE_WRAP, D3D12_TEXTURE_ADDRESS_MODE_WRAP, D3D12_TEXTURE_ADDRESS_MODE_WRAP),
                CD3DX12_STATIC_SAMPLER_DESC(1, D3D12_FILTER_MIN_MAG_MIP_LINEAR, D3D12_TEXTURE_ADDRESS_MODE_CLAMP, D3D12_TEXTURE_ADDRESS_MODE_CLAMP, D3D12_TEXTURE_ADDRESS_MODE_CLAMP),
                CD3DX12_STATIC_SAMPLER_DESC(2, D3D12_FILTER_MIN_MAG_MIP_LINEAR, D3D12_TEXTURE_ADDRESS_MODE_BORDER, D3D12_TEXTURE_ADDRESS_MODE_BORDER, D3D12_TEXTURE_ADDRESS_MODE_BORDER),
                CD3DX12_STATIC_SAMPLER_DESC(3, D3D12_FILTER_MIN_MAG_MIP_POINT, D3D12_TEXTURE_ADDRESS_MODE_WRAP, D3D12_TEXTURE_ADDRESS_MODE_WRAP, D3D12_TEXTURE_ADDRESS_MODE_WRAP),
                CD3DX12_STATIC_SAMPLER_DESC(4, D3D12_FILTER_MIN_MAG_MIP_POINT, D3D12_TEXTURE_ADDRESS_MODE_CLAMP, D3D12_TEXTURE_ADDRESS_MODE_CLAMP, D3D12_TEXTURE_ADDRESS_MODE_CLAMP),
                CD3DX12_STATIC_SAMPLER_DESC(5, D3D12_FILTER_MIN_MAG_MIP_POINT, D3D12_TEXTURE_ADDRESS_MODE_BORDER, D3D12_TEXTURE_ADDRESS_MODE_BORDER, D3D12_TEXTURE_ADDRESS_MODE_BORDER),
                CD3DX12_STATIC_SAMPLER_DESC(6, D3D12_FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT, D3D12_TEXTURE_ADDRESS_MODE_BORDER, D3D12_TEXTURE_ADDRESS_MODE_BORDER, D3D12_TEXTURE_ADDRESS_MODE_BORDER, 0.0f, 16, D3D12_COMPARISON_FUNC_LESS, D3D12_STATIC_BORDER_COLOR_OPAQUE_BLACK),
                CD3DX12_STATIC_SAMPLER_DESC(7, D3D12_FILTER_ANISOTROPIC, D3D12_TEXTURE_ADDRESS_MODE_CLAMP, D3D12_TEXTURE_ADDRESS_MODE_CLAMP, D3D12_TEXTURE_ADDRESS_MODE_CLAMP)};
        samplers[2].BorderColor = D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK;
        return samplers;
    }

    static std::pair<String, ShaderBindResourceInfo> ParserBindResource(D3D12_SHADER_INPUT_BIND_DESC bind_desc)
    {
        std::pair<String, ShaderBindResourceInfo> ret;
        auto res_type = bind_desc.Type;
        if (res_type == D3D_SHADER_INPUT_TYPE::D3D_SIT_CBUFFER)
        {
            ret = std::make_pair(bind_desc.Name, ShaderBindResourceInfo{EBindResDescType::kConstBuffer, static_cast<uint16_t>(bind_desc.BindPoint), 0u, bind_desc.Name});
        }
        else if (res_type == D3D_SHADER_INPUT_TYPE::D3D_SIT_TEXTURE)
        {
            ret = std::make_pair(bind_desc.Name, ShaderBindResourceInfo{EBindResDescType::kTexture2D, static_cast<uint16_t>(bind_desc.BindPoint), 0u, bind_desc.Name});
        }
        else if (res_type == D3D_SHADER_INPUT_TYPE::D3D_SIT_SAMPLER)
        {
            ret = std::make_pair(bind_desc.Name, ShaderBindResourceInfo{EBindResDescType::kSampler, static_cast<uint16_t>(bind_desc.BindPoint), 0u, bind_desc.Name});
        }
        else if (res_type == D3D_SHADER_INPUT_TYPE::D3D_SIT_STRUCTURED)
        {
            ret = std::make_pair(bind_desc.Name, ShaderBindResourceInfo{EBindResDescType::kBuffer, static_cast<uint16_t>(bind_desc.BindPoint), 0u, bind_desc.Name});
        }
        else if (res_type == D3D_SHADER_INPUT_TYPE::D3D_SIT_UAV_RWSTRUCTURED)
        {
            ret = std::make_pair(bind_desc.Name, ShaderBindResourceInfo{EBindResDescType::kRWBuffer, static_cast<uint16_t>(bind_desc.BindPoint), 0u, bind_desc.Name});
        }
        else if (res_type == D3D_SHADER_INPUT_TYPE::D3D_SIT_UAV_RWTYPED)
        {
            ret = std::make_pair(bind_desc.Name, ShaderBindResourceInfo{EBindResDescType::kUAVTexture2D, static_cast<uint16_t>(bind_desc.BindPoint), 0u, bind_desc.Name});
        }
        else
        {
            AL_ASSERT(true);
        }
        ret.second._register_space = bind_desc.Space;
        return ret;
    }

    static void ParserBindResourceAddiInfo(HashMap<String,ShaderBindResourceInfo>& bind_res_infos,String line)
    {
        line = line.find(";") != line.npos ? line.substr(0, line.find_first_of(";")+1) : line;
        if (su::BeginWith(line, "Texture2D"))
        {
            size_t name_begin = line.find_first_of("D") + 1;
            size_t name_end = line.find_first_of(":") - 1;
            String tex_name = line.substr(name_begin, name_end - name_begin);
        }
        else if (su::BeginWith(line, "TextureCube"))
        {
            size_t name_begin = line.find_last_of("e") + 1;
            size_t name_end = line.find_first_of(":") - 1;
            String tex_name = line.substr(name_begin, name_end - name_begin);
            auto it = bind_res_infos.find(tex_name);
            if (it != bind_res_infos.end())
            {
                it->second._res_type = EBindResDescType::kCubeMap;
            }
        }
        else if (su::BeginWith(line, "TEXTURECUBE"))
        {
            size_t name_begin = line.find_first_of("(") + 1;
            size_t name_end = line.find_last_of(",");
            String tex_name = line.substr(name_begin, name_end - name_begin);
            auto it = bind_res_infos.find(tex_name);
            if (it != bind_res_infos.end())
            {
                it->second._res_type = EBindResDescType::kCubeMap;
            }
        }
        else if (su::BeginWith(line, "Texture3D"))
        {
            auto eol = line.find_first_of("<") == line.length() ? "D" : ">";
            size_t name_begin = line.find_first_of(eol) + 1;
            size_t name_end = line.find_first_of(";");
            String tex_name = line.substr(name_begin, name_end - name_begin);
            su::RemoveSpaces(tex_name);
            auto it = bind_res_infos.find(tex_name);
            if (it != bind_res_infos.end())
            {
                it->second._res_type = EBindResDescType::kTexture3D;
            }
        }
        else if (su::BeginWith(line, "TEXTURE3D"))
        {
            size_t name_begin = line.find_first_of("(") + 1;
            size_t name_end = line.find_first_of(")");
            String tex_name = line.substr(name_begin, name_end - name_begin);
            auto it = bind_res_infos.find(tex_name);
            if (it != bind_res_infos.end())
            {
                it->second._res_type = EBindResDescType::kTexture3D;
            }
        }
        else if (su::BeginWith(line, "RWTexture3D"))
        {
            auto eol = line.find_first_of("<") == line.length() ? "D" : ">";
            size_t name_begin = line.find_first_of(eol) + 1;
            size_t name_end = line.find_first_of(";");
            String tex_name = line.substr(name_begin, name_end - name_begin);
            su::RemoveSpaces(tex_name);
            auto it = bind_res_infos.find(tex_name);
            if (it != bind_res_infos.end())
            {
                it->second._res_type = EBindResDescType::kRWTexture3D;
            }
        }
        else if (su::BeginWith(line, "RWTEXTURE3D"))//RWTEXTURE3D(_OutNoise3D,float4)
        {
            size_t name_begin = line.find_first_of('(') + 1;
            size_t name_end = line.find_first_of(",");
            String tex_name = line.substr(name_begin, name_end - name_begin);
            su::RemoveSpaces(tex_name);
            auto it = bind_res_infos.find(tex_name);
            if (it != bind_res_infos.end())
            {
                it->second._res_type = EBindResDescType::kRWTexture3D;
            }
        }
        else if (su::BeginWith(line, "RWBuffer"))
        {
            auto eol = line.find_first_of("<") == line.length() ? "r" : ">";
            size_t name_begin = line.find_first_of(eol) + 1;
            size_t name_end = line.find_first_of(";");
            String tex_name = line.substr(name_begin, name_end - name_begin);
            su::RemoveSpaces(tex_name);
            auto it = bind_res_infos.find(tex_name);
            if (it != bind_res_infos.end())
            {
                it->second._res_type = EBindResDescType::kRWBuffer;
            }
        }
        else if (su::BeginWith(line, "uint"))
        {
            std::regex pattern(R"(^(\w+)\s+(\w+)\s*(\[\d*\])?\s*;)");
            std::smatch matches;
            if (std::regex_match(line, matches, pattern))
            {
                const auto &type_name = matches[1].str();
                const auto &value_name = matches[2].str();
                u8 array_size = matches[3].str().empty()? 0u : (u8)std::stoi(matches[3].str().substr(1,matches[3].str().size()-2));
                auto it = bind_res_infos.find(value_name);
                if (it != bind_res_infos.end())
                {
                    auto &c = it->second;
                    c._array_size = array_size;
                    if (type_name == "uint4" || type_name == "uint3" || type_name == "uint2")
                        c._res_type = (EBindResDescType) (EBindResDescType::kCBufferAttribute | EBindResDescType::kCBufferUInts);
                    else
                        c._res_type = (EBindResDescType) (EBindResDescType::kCBufferAttribute | EBindResDescType::kCBufferUInt);
                }
            }
        }
        else if (su::BeginWith(line, "int"))
        {
            std::regex pattern(R"(^(\w+)\s+(\w+)\s*(\[\d*\])?\s*;)");
            std::smatch matches;
            if (std::regex_match(line, matches, pattern))
            {
                const auto &type_name = matches[1].str();
                const auto &value_name = matches[2].str();
                u8 array_size = matches[3].str().empty()? 0u : (u8)std::stoi(matches[3].str().substr(1,matches[3].str().size()-2));
                auto it = bind_res_infos.find(value_name);
                if (it != bind_res_infos.end())
                {
                    auto &c = it->second;
                    c._array_size = array_size;
                    if (type_name == "int4" || type_name == "int3" || type_name == "int2")
                        c._res_type = (EBindResDescType) (EBindResDescType::kCBufferAttribute | EBindResDescType::kCBufferInts);
                    else
                        c._res_type = (EBindResDescType) (EBindResDescType::kCBufferAttribute | EBindResDescType::kCBufferInt);
                }
            }
        }
        else if (su::BeginWith(line, "float"))//默认所有4字节大小的均为float，所以这里不需要调整其类型
        {
            std::regex pattern(R"(^(\w+)\s+(\w+)\s*(\[\d*\])?\s*;)");
            std::smatch matches;
            if (std::regex_match(line, matches, pattern))
            {
                const auto &type_name = matches[1].str();
                const auto &value_name = matches[2].str();
                u8 array_size = matches[3].str().empty()? 0u : (u8)std::stoi(matches[3].str().substr(1,matches[3].str().size()-2));
                auto it = bind_res_infos.find(value_name);
                if (it != bind_res_infos.end())
                {
                    auto &c = it->second;
                    c._array_size = array_size;
                }
            }
        }
        else if (su::BeginWith(line, "bool"))
        {
            std::regex pattern(R"(^(\w+)\s+(\w+)\s*(\[\d*\])?\s*;)");
            std::smatch matches;
            if (std::regex_match(line, matches, pattern))
            {
                const auto &type_name = matches[1].str();
                const auto &value_name = matches[2].str();
                auto it = bind_res_infos.find(value_name);
                if (it != bind_res_infos.end())
                {
                    auto &c = it->second;
                    c._res_type = (EBindResDescType) (EBindResDescType::kCBufferAttribute | EBindResDescType::kCBufferBool);
                }
            }
        }
        else if (su::BeginWith(line, "float4x4"))
        {
            std::regex pattern(R"(^(\w+)\s+(\w+)\s*(\[\d*\])?\s*;)");
            std::smatch matches;
            if (std::regex_match(line, matches, pattern))
            {
                const auto &type_name = matches[1].str();
                const auto &value_name = matches[2].str();
                u8 array_size = matches[3].str().empty()? 0u : (u8)std::stoi(matches[3].str().substr(1,matches[3].str().size()-2));
                auto it = bind_res_infos.find(value_name);
                if (it != bind_res_infos.end())
                {
                    auto &c = it->second;
                    c._res_type = (EBindResDescType) (EBindResDescType::kCBufferAttribute | EBindResDescType::kCBufferMatrix);
                    c._array_size = array_size;
                }
            }
        }
        else {};
    }

    static ShaderBindResourceInfo ParserBindVariable(const D3D12_SHADER_VARIABLE_DESC &desc)
    {
        u16 offset = (u16) desc.StartOffset;
        u16 size = (u16) desc.Size;
        u32 variable_info = 0u;
        variable_info |= offset;
        variable_info <<= 16;
        variable_info |= size;
        auto value_type = EBindResDescType::kCBufferAttribute;
        if (size == 4) value_type = (EBindResDescType) (EBindResDescType::kCBufferFloat | value_type);
        else if (size == 16 || size == 12 || size == 8)
            value_type = (EBindResDescType) (EBindResDescType::kCBufferFloats | value_type);
        else if (size == 64)
            value_type = (EBindResDescType) (EBindResDescType::kCBufferMatrix | value_type);
        else {}
        auto info = ShaderBindResourceInfo{value_type, variable_info, 0u, desc.Name};
        return info;
    }
    
    static Vector<D3D_SHADER_MACRO> ConstructVariantMarcos(const std::set<String>& kw_seqs)
    {
        Vector<D3D_SHADER_MACRO> v;
        for (const auto& kw : Shader::GetPreDefinedMacros())
            v.emplace_back(D3D_SHADER_MACRO{kw.c_str(), "1"});
        for (auto &kw: kw_seqs)
        {
            if (kw != "_")
            {
                v.emplace_back(D3D_SHADER_MACRO{kw.c_str(), "1"});
            }
        }
        v.emplace_back(D3D_SHADER_MACRO{NULL, NULL});
        return v;
    }
    //-------------------------------------------------------------D3DShaderInclude------------------------------------------------------------------
    HRESULT D3DShaderInclude::Open(D3D_INCLUDE_TYPE IncludeType, LPCSTR pFileName, LPCVOID pParentData, LPCVOID *ppData, UINT *pBytes)
    {
        for (auto &include_path: _addi_include_pathes)
        {
            std::lock_guard<std::mutex> l(s_compile_lock);
            WString p;
            if ((const char *) pFileName[0] == ".")
            {
                p = PathUtils::ResolveRelPath(pFileName, _cur_source_file_path);
            }
            else
            {
                p = ResourceMgr::GetResSysPath(include_path) + ToWStr(pFileName);
            }
            if (FileManager::Exist(p))
            {
                auto [file_data, byte_size] = FileManager::ReadFile(p);
                _data = file_data;
                *ppData = _data;
                *pBytes = byte_size;
                _include_files.insert(p);
                return S_OK;
            }
            //AL_ASSERT(true);
        }
        AL_ASSERT(true);
        return E_FAIL;
    }

    HRESULT D3DShaderInclude::Close(LPCVOID pData)
    {
        delete[] pData;
        return S_OK;
    }
    //-------------------------------------------------------------D3DShaderInclude------------------------------------------------------------------

#pragma region D3DShader
    D3DShader::D3DShader(const WString &sys_path) : Shader(sys_path)
    {
        Compile();
    }
    D3DShader::~D3DShader()
    {
    }

    void D3DShader::GenerateInternalPSO(u16 pass_index, ShaderVariantHash variant_hash)
    {
        AL_ASSERT(pass_index < _passes.size());
        AL_ASSERT(_passes[pass_index]._variants.contains(variant_hash));
        AL_ASSERT(pass_index < _pass_elements.size());
        AL_ASSERT(_pass_elements[pass_index]._variants.contains(variant_hash));
        D3D12_FEATURE_DATA_ROOT_SIGNATURE featureData = {};
        featureData.HighestVersion = D3D_ROOT_SIGNATURE_VERSION_1_1;
        auto device = D3DContext::Get()->GetDevice();
        if (FAILED(device->CheckFeatureSupport(D3D12_FEATURE_ROOT_SIGNATURE, &featureData, sizeof(featureData))))
        {
            featureData.HighestVersion = D3D_ROOT_SIGNATURE_VERSION_1_0;
        }
        CD3DX12_DESCRIPTOR_RANGE1 ranges[32]{};
        CD3DX12_ROOT_PARAMETER1 rootParameters[32]{};
        int cbuf_mask = 0, texture_count = 0;
        auto &pass_variant = _passes[pass_index]._variants[variant_hash];
        auto &variant_bind_res_info = pass_variant._bind_res_infos;
        for (auto it = variant_bind_res_info.begin(); it != variant_bind_res_info.end(); it++)
        {
            auto &desc = it->second;
            //if (desc._res_type == EBindResDescType::kCBufferAttribute) continue;
            if (desc._res_type == EBindResDescType::kConstBuffer)
            {
                if (desc._name == RenderConstants::kCBufNamePerObject)
                    cbuf_mask |= 0x01;
                else if (desc._name == RenderConstants::kCBufNamePerMaterial)
                    cbuf_mask |= 0x02;
                else if (desc._name == RenderConstants::kCBufNamePerCamera)
                    cbuf_mask |= 0x04;
                else if (desc._name == RenderConstants::kCBufNamePerScene)
                    cbuf_mask |= 0x08;
            }
        }
        u8 root_param_index = 0;
        if (cbuf_mask & 0x01)
        {
            variant_bind_res_info[RenderConstants::kCBufNamePerObject]._bind_slot = root_param_index;
            rootParameters[root_param_index++].InitAsConstantBufferView(0u);
        }
        if (cbuf_mask & 0x02)
        {
            variant_bind_res_info[RenderConstants::kCBufNamePerMaterial]._bind_slot = root_param_index;
            pass_variant._per_mat_buf_bind_slot = root_param_index;
            rootParameters[root_param_index++].InitAsConstantBufferView(1u);
        }
        if (cbuf_mask & 0x04)
        {
            variant_bind_res_info[RenderConstants::kCBufNamePerCamera]._bind_slot = root_param_index;
            pass_variant._per_pass_buf_bind_slot = root_param_index;
            rootParameters[root_param_index++].InitAsConstantBufferView(3u);
        }
        if (cbuf_mask & 0x08)
        {
            variant_bind_res_info[RenderConstants::kCBufNamePerScene]._bind_slot = root_param_index;
            pass_variant._per_frame_buf_bind_slot = root_param_index;
            rootParameters[root_param_index++].InitAsConstantBufferView(2u);
        }
        for (auto it = variant_bind_res_info.begin(); it != variant_bind_res_info.end(); it++)
        {
            auto &desc = it->second;
            switch (desc._res_type)
            {
                case EBindResDescType::kTexture2D:
                case EBindResDescType::kUAVTexture2D:
                case EBindResDescType::kTexture3D:
                case EBindResDescType::kCubeMap:
                {
                    ++texture_count;
                    ranges[root_param_index].Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, desc._res_slot);
                    rootParameters[root_param_index].InitAsDescriptorTable(1, &ranges[root_param_index]);
                    desc._bind_slot = root_param_index;
                    ++root_param_index;
                }
                break;
                case EBindResDescType::kRWBuffer:
                case EBindResDescType::kBuffer:
                {
                    ranges[root_param_index].Init(D3D12_DESCRIPTOR_RANGE_TYPE_UAV, 1, desc._res_slot);
                    rootParameters[root_param_index].InitAsDescriptorTable(1, &ranges[root_param_index]);
                    desc._bind_slot = root_param_index;
                    ++root_param_index;
                }
                break;
                default:
                    break;
            }
        }
        D3D12_ROOT_SIGNATURE_FLAGS rootSignatureFlags =
                D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |
                D3D12_ROOT_SIGNATURE_FLAG_DENY_HULL_SHADER_ROOT_ACCESS |
                D3D12_ROOT_SIGNATURE_FLAG_DENY_DOMAIN_SHADER_ROOT_ACCESS;
        if (_pass_elements[pass_index]._variants[variant_hash]._p_gblob == nullptr)
            rootSignatureFlags |= D3D12_ROOT_SIGNATURE_FLAG_DENY_GEOMETRY_SHADER_ROOT_ACCESS;
        CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC rootSignatureDesc;
        auto samplers = CreateStaticSampler();
        rootSignatureDesc.Init_1_1(root_param_index, rootParameters, static_cast<UINT>(samplers.size()), samplers.data(), rootSignatureFlags);
        ComPtr<ID3DBlob> signature;
        ComPtr<ID3DBlob> error;
        auto hr = D3DX12SerializeVersionedRootSignature(&rootSignatureDesc, featureData.HighestVersion, &signature, &error);
        if (error)
        {
            LOG_ERROR("Root signature error: {}", (const char *) error->GetBufferPointer());
        }
        ThrowIfFailed(hr);
        //如果参数一致，实际上会从池中返回已有的根签名，这就意味着在使用一个重复的根签名之前，需要清空其绑定的资源
        ThrowIfFailed(device->CreateRootSignature(0, signature->GetBufferPointer(), signature->GetBufferSize(), IID_PPV_ARGS(&_pass_elements[pass_index]._variants[variant_hash]._p_sig)));
    }

    bool D3DShader::RHICompileImpl(u16 pass_index, ShaderVariantHash variant_hash)
    {
        bool succeed = true;
        ComPtr<ID3DBlob> tmp_p_vblob;
        ComPtr<ID3DBlob> tmp_p_pblob;
        ComPtr<ID3DBlob> tmp_p_gblob;
        ComPtr<ID3D12ShaderReflection> tmp_p_vreflect, tmp_p_preflect, tmp_p_greflect;
        Vector<D3D_SHADER_MACRO> keyword_defines;
        try
        {
            //应该可以把全部元素都清空，pso在运行时似乎没有再引用这里的东西
            if (!_is_pass_elements_init.load())
            {
                Reset();
                _is_pass_elements_init.store(true);
            }
            auto &pass = _passes[pass_index];
            keyword_defines = ConstructVariantMarcos(pass._variants[variant_hash]._active_keywords);
#ifdef SHADER_DXC
            CreateFromFileDXC(ToWStr(file_name.data()), L"VSMain", D3DConstants::kVSModel_6_1, _p_vblob, _p_reflection);
            LoadShaderReflection(_p_reflection.Get());
            CreateFromFileDXC(ToWStr(file_name.data()), L"PSMain", D3DConstants::kPSModel_6_1, _p_pblob, _p_reflection);
            LoadShaderReflection(_p_reflection.Get());
#else
            succeed &= CreateFromFileFXC(pass._vert_src_file, pass._vert_entry, RenderConstants::kVSModel_5_0, keyword_defines, tmp_p_vblob, tmp_p_vreflect, pass._source_files, _is_first_compile);
            succeed &= CreateFromFileFXC(pass._pixel_src_file, pass._pixel_entry, RenderConstants::kPSModel_5_0, keyword_defines, tmp_p_pblob, tmp_p_preflect, pass._source_files, _is_first_compile);
            if (!pass._geometry_entry.empty())
                succeed &= CreateFromFileFXC(pass._geom_src_file, pass._geometry_entry, RenderConstants::kGSModel_5_0, keyword_defines, tmp_p_gblob, tmp_p_greflect, pass._source_files, _is_first_compile);
            _is_first_compile = false;
#endif// SHADER_DXC
        }
        catch (const std::exception &)
        {
            succeed = false;
            g_pLogMgr->LogErrorFormat(L"Compile shader with src {0} failed!", _src_file_path);
        }
        if (succeed)
        {
            _pass_elements[pass_index]._variants.insert(std::make_pair(variant_hash, D3DShaderElement::D3DVariantElement()));
            LoadShaderReflection(pass_index, variant_hash, tmp_p_vreflect.Get(), tmp_p_preflect.Get());
            _pass_elements[pass_index]._variants[variant_hash]._p_vblob = tmp_p_vblob;
            _pass_elements[pass_index]._variants[variant_hash]._p_pblob = tmp_p_pblob;
            _pass_elements[pass_index]._variants[variant_hash]._p_gblob = tmp_p_gblob;
            _pass_elements[pass_index]._variants[variant_hash]._keyword_defines = keyword_defines;
            GenerateInternalPSO(pass_index, variant_hash);
        }
        return succeed;
    }

    void D3DShader::LoadAdditionalShaderReflection(const WString &sys_path, u16 pass_index, ShaderVariantHash variant_hash)
    {
        using namespace std;
        namespace su = StringUtils;
        namespace fs = std::filesystem;
        ifstream src(sys_path, ios::in);
        string line;
        vector<string> lines;
        List<WString> cur_file_head_files{};
        WString parent_path = su::SubStrRange(_src_file_path, 0, _src_file_path.find_last_of(L"/"));
        while (getline(src, line))
        {
            line = su::Trim(line);
            if (su::BeginWith(line,"//"))
            {
                lines.emplace_back(line);
                continue;
            }
            ParserBindResourceAddiInfo(_passes[pass_index]._variants[variant_hash]._bind_res_infos,line);
            lines.emplace_back(line);
        }
        src.close();
        fs::path src_path(sys_path);
        fs::path pwd = src_path.parent_path();
        for (auto &head_file: cur_file_head_files)
        {
            fs::path temp = pwd;
            temp.append(head_file);
            LoadAdditionalShaderReflection(temp.wstring(), pass_index, variant_hash);
        }
    }

    std::pair<D3D12_INPUT_ELEMENT_DESC *, u8> D3DShader::GetVertexInputLayout(u16 pass_index, ShaderVariantHash variant_hash)
    {
        return std::make_pair(_pass_elements[pass_index]._variants[variant_hash]._vertex_input_layout, _passes[pass_index]._variants[variant_hash]._vertex_input_num);
    }

    void D3DShader::Reset()
    {
        //_pass_elements.clear();
        _pass_elements.resize(_passes.size());
        //for (int i = 0; i < _passes.size(); i++)
        //{
        //	_pass_elements[i] = D3DShaderElement();
        //	//if (_pass_elements[i]._p_vblob != nullptr) _pass_elements[i]._p_vblob.Reset();
        //	//if (_pass_elements[i]._p_pblob != nullptr) _pass_elements[i]._p_pblob.Reset();
        //	//if (_pass_elements[i]._p_v_reflection != nullptr) _pass_elements[i]._p_v_reflection.Reset();
        //	//if (_pass_elements[i]._p_p_reflection != nullptr) _pass_elements[i]._p_p_reflection.Reset();
        //	//memset(_pass_elements[i]._vertex_input_layout, 0, sizeof(D3D12_INPUT_ELEMENT_DESC) * RenderConstants::kMaxVertexAttrNum);
        //	//_passes[i]._vertex_input_num = 0u;
        //	_passes[i]._pipeline_topology = ETopology::kTriangle;
        //}
    }
    void D3DShader::LoadShaderReflection(u16 pass_index, ShaderVariantHash variant_hash, ID3D12ShaderReflection *ref_vs, ID3D12ShaderReflection *ref_ps)
    {
        AL_ASSERT(pass_index < _passes.size());
        auto &pass = _passes[pass_index];
        AL_ASSERT(pass._variants.contains(variant_hash));
        auto &pass_variant = pass._variants[variant_hash];
        D3D12_SHADER_DESC desc{};
        //parser vs reflecton
        {
            ref_vs->GetDesc(&desc);
            if (desc.InputParameters > 10)
            {
                AL_ASSERT_MSG(false, "LayoutDesc count must less than 10");
                return;
            }
            Vector<VertexBufferLayoutDesc> vb_input_desc{};
            for (u32 i = 0u; i < desc.InputParameters; i++)
            {
                D3D12_SIGNATURE_PARAMETER_DESC input_desc{};
                ref_vs->GetInputParameterDesc(i, &input_desc);
                EShaderDateType data_type = D3DConvertUtils::GetShaderDataType(input_desc.SemanticName, input_desc.Mask);
                _pass_elements[pass_index]._variants[variant_hash]._vertex_input_layout[i] = D3D12_INPUT_ELEMENT_DESC{input_desc.SemanticName, 0, D3DConvertUtils::GetGXGIFormatByShaderDataType(data_type), i, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0};
                if (data_type != EShaderDateType::kNone)
                {
                    vb_input_desc.emplace_back(input_desc.SemanticName, data_type, input_desc.Register,input_desc.SemanticIndex);
                }
                else
                {
                    g_pLogMgr->LogWarningFormat("LoadShaderReflection {} skip input element: {}", _name, input_desc.SemanticName);
                }
            }
            pass_variant._vertex_input_num = (u8) vb_input_desc.size();
            pass_variant._pipeline_input_layout = VertexBufferLayout(vb_input_desc);
            pass_variant._bind_res_infos.clear();
            for (u32 i = 0u; i < desc.BoundResources; i++)
            {
                D3D12_SHADER_INPUT_BIND_DESC bind_desc{};
                ref_vs->GetResourceBindingDesc(i, &bind_desc);
                pass_variant._bind_res_infos.insert(ParserBindResource(bind_desc));
            }
            for (u32 i = 0u; i < desc.ConstantBuffers; i++)
            {
                auto cbuf = ref_vs->GetConstantBufferByIndex(i);
                D3D12_SHADER_BUFFER_DESC desc{};
                cbuf->GetDesc(&desc);
                u8 flag = ShaderBindResourceInfo::GetBindResourceFlag(desc.Name);
                for (u32 j = 0u; j < desc.Variables; j++)
                {
                    auto variable = cbuf->GetVariableByIndex(j);
                    D3D12_SHADER_VARIABLE_DESC vdesc{};
                    variable->GetDesc(&vdesc);
                    auto info = ParserBindVariable(vdesc);
                    info._bind_flag = flag;
                    info._p_root_cbuf = &pass_variant._bind_res_infos.find(desc.Name)->second;
                    pass_variant._bind_res_infos.insert(std::make_pair(vdesc.Name, info));
                }
            }
        }
        //parser ps reflecton
        {
            ref_ps->GetDesc(&desc);
            for (u32 i = 0u; i < desc.BoundResources; i++)
            {
                D3D12_SHADER_INPUT_BIND_DESC bind_desc{};
                ref_ps->GetResourceBindingDesc(i, &bind_desc);
                //LOG_INFO("Name:{},Slot{},Space{}", bind_desc.Name, bind_desc.BindPoint, bind_desc.Space);
                pass_variant._bind_res_infos.insert(ParserBindResource(bind_desc));
            }
            for (u32 i = 0u; i < desc.ConstantBuffers; i++)
            {
                auto cbuf = ref_ps->GetConstantBufferByIndex(i);
                D3D12_SHADER_BUFFER_DESC desc{};
                cbuf->GetDesc(&desc);
                u8 flag = ShaderBindResourceInfo::GetBindResourceFlag(desc.Name);
                for (u32 j = 0u; j < desc.Variables; j++)
                {
                    auto variable = cbuf->GetVariableByIndex(j);
                    D3D12_SHADER_VARIABLE_DESC vdesc{};
                    variable->GetDesc(&vdesc);
                    auto info = ParserBindVariable(vdesc);
                    info._bind_flag = flag;
                    pass_variant._bind_res_infos.insert(std::make_pair(vdesc.Name, info));
                }
            }
        }
        //parser additon info
        LoadAdditionalShaderReflection(_src_file_path, pass_index, variant_hash);
        //for (auto &p: pass._source_files)
        //    LoadAdditionalShaderReflection(p, pass_index, variant_hash);
    }

    void D3DShader::Bind(u16 pass_index, ShaderVariantHash variant_hash)
    {
        Shader::Bind(pass_index, variant_hash);
    }

    void *D3DShader::GetByteCode(EShaderType type, u16 pass_index, ShaderVariantHash variant_hash)
    {
        switch (type)
        {
            case Ailu::EShaderType::kVertex:
                return reinterpret_cast<void *>(_pass_elements[pass_index]._variants[variant_hash]._p_vblob.Get());
            case Ailu::EShaderType::kPixel:
                return reinterpret_cast<void *>(_pass_elements[pass_index]._variants[variant_hash]._p_pblob.Get());
            case EShaderType::kGeometry:
                return reinterpret_cast<void *>(_pass_elements[pass_index]._variants[variant_hash]._p_gblob.Get());
        }
        return nullptr;
    }

    ID3D12RootSignature *D3DShader::GetSignature(u16 pass_index, ShaderVariantHash variant_hash)
    {
        return _pass_elements[pass_index]._variants[variant_hash]._p_sig.Get();
    }

#pragma endregion

#pragma region D3DComputeShader
    //-------------------------------------------------------------------------------D3DComputeShader---------------------------------------------------------------------------
    D3DComputeShader::D3DComputeShader(const WString &sys_path) : ComputeShader(sys_path)
    {
        Compile();
    }

    void D3DComputeShader::Bind(CommandBuffer *cmd, u16 kernel, u16 thread_group_x, u16 thread_group_y, u16 thread_group_z)
    {
        if (!_is_valid && kernel >= _kernels.size())
        {
            LOG_WARNING("ComputeShader or kernel id is not valid!");
            return;
        }
        ComputeShader::Bind(cmd, kernel, thread_group_x, thread_group_y, thread_group_z);
        ShaderVariantHash cur_hash = _kernels[kernel]._active_variant;
        if (_variant_state[kernel][cur_hash] != EShaderVariantState::kReady)
            return;
        auto d3dcmd = static_cast<D3DCommandBuffer *>(cmd)->GetCmdList();
        auto &d3d_ele = _elements[kernel]._variants[cur_hash];
        auto &cs_ele = _kernels[kernel]._variants[cur_hash];
        d3dcmd->SetPipelineState(d3d_ele._pso.Get());
        d3dcmd->SetComputeRootSignature(d3d_ele._p_sig.Get());
        for (auto &info: cs_ele._bind_res_infos)
        {
            auto &bind_info = info.second;
            if (bind_info._p_res != nullptr)
            {
                auto &view_info = _texture_addi_bind_info[bind_info._bind_slot];
                if (bind_info._res_type == EBindResDescType::kTexture2D)
                {
                    auto tex = static_cast<Texture2D *>(bind_info._p_res);
                    u16 view_index = view_info._view_index == (u16)-1? tex->CalculateViewIndex(Texture::ETextureViewType::kSRV, view_info._face, view_info._mipmap, 0) : view_info._view_index;
                    tex->Bind(cmd, view_index, bind_info._bind_slot, view_info._sub_res, true);
                }
                else if (bind_info._res_type == EBindResDescType::kUAVTexture2D)
                {
                    auto tex = static_cast<Texture *>(bind_info._p_res);
                    tex->Bind(cmd, tex->CalculateViewIndex(Texture::ETextureViewType::kUAV, view_info._face, view_info._mipmap, 0), bind_info._bind_slot, view_info._sub_res, true);
                }
                if (bind_info._res_type == EBindResDescType::kTexture3D)
                {
                    auto tex = static_cast<Texture3D *>(bind_info._p_res);
                    u16 view_index = view_info._view_index == (u16)-1? tex->CalculateViewIndex(Texture::ETextureViewType::kSRV, view_info._face, view_info._mipmap, view_info._slice): view_info._view_index;
                    tex->Bind(cmd, view_index, bind_info._bind_slot, view_info._sub_res, true);
                }
                else if (bind_info._res_type == EBindResDescType::kRWTexture3D)
                {
                    auto tex = static_cast<Texture3D *>(bind_info._p_res);
                    tex->Bind(cmd, tex->CalculateViewIndex(Texture::ETextureViewType::kUAV, view_info._face, view_info._mipmap, view_info._slice), bind_info._bind_slot, view_info._sub_res, true);
                }
                else if (bind_info._res_type == EBindResDescType::kRWBuffer)
                {
                    auto buf = static_cast<IGPUBuffer *>(bind_info._p_res);
                    buf->Bind(cmd, bind_info._bind_slot, true);
                }
                else if (bind_info._res_type == EBindResDescType::kConstBuffer)
                {
                    reinterpret_cast<IConstantBuffer *>(bind_info._p_res)->Bind(cmd, bind_info._bind_slot, true);
                }
            }
            else
            {
                if (bind_info._res_type == EBindResDescType::kConstBuffer)
                {

                    cmd->SetComputeBuffer(bind_info._name, kernel, _cbuf_data, sizeof(_cbuf_data));
                }
            }
        }
        //d3dcmd->Dispatch(thread_group_x, thread_group_y, thread_group_z);
    }

    void D3DComputeShader::LoadReflectionInfo(ID3D12ShaderReflection *p_reflect, u16 kernel_index,ShaderVariantHash variant_hash)
    {
        auto &cs_ele = _kernels[kernel_index]._variants[variant_hash];
        D3D12_SHADER_DESC desc{};
        cs_ele._temp_bind_res_infos.clear();
        //parser vs reflecton
        p_reflect->GetDesc(&desc);
        p_reflect->GetThreadGroupSize(&_kernels[kernel_index]._thread_num.x, &_kernels[kernel_index]._thread_num.y, &_kernels[kernel_index]._thread_num.z);
        for (u32 i = 0u; i < desc.BoundResources; i++)
        {
            D3D12_SHADER_INPUT_BIND_DESC bind_desc{};
            p_reflect->GetResourceBindingDesc(i, &bind_desc);
            cs_ele._temp_bind_res_infos.insert(ParserBindResource(bind_desc));
        }
        for (u32 i = 0u; i < desc.ConstantBuffers; i++)
        {
            auto cbuf = p_reflect->GetConstantBufferByIndex(i);
            D3D12_SHADER_BUFFER_DESC desc{};
            cbuf->GetDesc(&desc);
            for (u32 j = 0u; j < desc.Variables; j++)
            {
                auto variable = cbuf->GetVariableByIndex(j);
                D3D12_SHADER_VARIABLE_DESC vdesc{};
                variable->GetDesc(&vdesc);
                auto info = ParserBindVariable(vdesc);
                info._p_root_cbuf = &cs_ele._temp_bind_res_infos.find(desc.Name)->second;
                cs_ele._temp_bind_res_infos.insert(std::make_pair(vdesc.Name, info));
            }
        }
    }
    //https://rtarun9.github.io/blogs/shader_reflection/#reflecting-input-parameters
    void D3DComputeShader::LoadAdditionalShaderReflection(const WString &sys_path, u16 kernel_index, ShaderVariantHash variant_hash)
    {
        using namespace std;
        namespace su = StringUtils;
        namespace fs = std::filesystem;
        ifstream src(sys_path, ios::in);
        string line;
        vector<string> lines;
        List<WString> cur_file_head_files{};
        WString parent_path = su::SubStrRange(_src_file_path, 0, _src_file_path.find_last_of(L"/"));
        auto& cur_kernel = _kernels[kernel_index]._variants[variant_hash];
        while (getline(src, line))
        {
            line = su::Trim(line);
            if (su::BeginWith(line,"//"))
            {
                lines.emplace_back(line);
                continue;
            }
            ParserBindResourceAddiInfo(_kernels[kernel_index]._variants[variant_hash]._temp_bind_res_infos,line);
            lines.emplace_back(line);
        }
        src.close();
        fs::path src_path(sys_path);
        fs::path pwd = src_path.parent_path();
        for (auto &head_file: cur_file_head_files)
        {
            fs::path temp = pwd;
            temp.append(head_file);
            LoadAdditionalShaderReflection(temp.wstring(), kernel_index, variant_hash);
        }
    }

    bool D3DComputeShader::RHICompileImpl(u16 kernel_index,ShaderVariantHash variant_hash)
    {
        if (kernel_index >= _kernels.size())
            return false;
        {
            std::lock_guard<std::mutex> lock(_ele_lock);
            if (kernel_index >= _elements.size())
                _elements.resize(kernel_index + 1);
        }
        bool succeed = true;
        ComPtr<ID3DBlob> tmp_blob = nullptr;
        ComPtr<ID3D12ShaderReflection> tmp_reflection{nullptr};
        std::set<WString> tmp_all_dep_file_pathes;
        //Vector<D3D_SHADER_MACRO> v = {{"COMPUTE", "1"}, {NULL, NULL}};
        auto& cur_variant = _kernels[kernel_index]._variants[variant_hash];
        Vector<D3D_SHADER_MACRO> marcos = ConstructVariantMarcos(cur_variant._active_keywords);
        try
        {
#ifdef SHADER_DXC
            CreateFromFileDXC(ToWStr(file_name.data()), L"VSMain", D3DConstants::kVSModel_6_1, _p_vblob, _p_reflection);
            LoadShaderReflection(_p_reflection.Get());
#else
            succeed &= CreateFromFileFXC(_src_file_path, _kernels[kernel_index]._name, RenderConstants::kCSModel_5_0, marcos, tmp_blob, tmp_reflection, tmp_all_dep_file_pathes);
#endif// SHADER_DXC
        }
        catch (const std::exception &)
        {
            succeed = false;
            g_pLogMgr->LogErrorFormat(L"Compile shader with src {0} failed!", _src_file_path);
            _is_valid = false;
        }
        if (succeed)
        {
            for(auto& p : tmp_all_dep_file_pathes)
                cur_variant._all_dep_file_pathes.insert(p);
            _elements[kernel_index]._variants[variant_hash]._p_blob = tmp_blob;
            LoadReflectionInfo(tmp_reflection.Get(), kernel_index,variant_hash);
            LoadAdditionalShaderReflection(_src_file_path, kernel_index,variant_hash);
            GenerateInternalPSO(kernel_index,variant_hash);
            succeed = _is_valid;
            g_pLogMgr->LogFormat(L"Compile shader with src {0} succeed!", _src_file_path);
        }
        return succeed;
    }

    void D3DComputeShader::GenerateInternalPSO(u16 kernel_index,ShaderVariantHash variant_hash)
    {
        D3D12_FEATURE_DATA_ROOT_SIGNATURE featureData = {};
        featureData.HighestVersion = D3D_ROOT_SIGNATURE_VERSION_1_1;
        auto device = D3DContext::Get()->GetDevice();
        if (FAILED(device->CheckFeatureSupport(D3D12_FEATURE_ROOT_SIGNATURE, &featureData, sizeof(featureData))))
        {
            featureData.HighestVersion = D3D_ROOT_SIGNATURE_VERSION_1_0;
        }
        CD3DX12_DESCRIPTOR_RANGE1 ranges[32]{};
        CD3DX12_ROOT_PARAMETER1 rootParameters[32]{};
        int cbuf_mask = 0, texture_count = 0;
        u8 root_param_index = 0;
        auto &cs_ele = _kernels[kernel_index]._variants[variant_hash];
        for (auto it = cs_ele._temp_bind_res_infos.begin(); it != cs_ele._temp_bind_res_infos.end(); it++)
        {
            auto &desc = it->second;
            if (desc._res_type == EBindResDescType::kTexture2D || desc._res_type == EBindResDescType::kTexture3D)
            {
                ++texture_count;
                ranges[root_param_index].Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, desc._res_slot);
                rootParameters[root_param_index].InitAsDescriptorTable(1, &ranges[root_param_index]);
                desc._bind_slot = root_param_index;
                ++root_param_index;
            }
            if (desc._res_type == EBindResDescType::kBuffer)
            {
                ranges[root_param_index].Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, desc._res_slot);
                rootParameters[root_param_index].InitAsDescriptorTable(1, &ranges[root_param_index]);
                desc._bind_slot = root_param_index;
                ++root_param_index;
            }
            else if (desc._res_type == EBindResDescType::kUAVTexture2D || desc._res_type == EBindResDescType::kRWTexture3D)
            {
                ++texture_count;
                ranges[root_param_index].Init(D3D12_DESCRIPTOR_RANGE_TYPE_UAV, 1, desc._res_slot);
                rootParameters[root_param_index].InitAsDescriptorTable(1, &ranges[root_param_index]);
                desc._bind_slot = root_param_index;
                ++root_param_index;
            }
            else if (desc._res_type == EBindResDescType::kRWBuffer)
            {
                ranges[root_param_index].Init(D3D12_DESCRIPTOR_RANGE_TYPE_UAV, 1, desc._res_slot);
                rootParameters[root_param_index].InitAsDescriptorTable(1, &ranges[root_param_index]);
                desc._bind_slot = root_param_index;
                ++root_param_index;
            }
            else if (desc._res_type == EBindResDescType::kConstBuffer)
            {
                rootParameters[root_param_index].InitAsConstantBufferView(desc._res_slot, 0);
                desc._bind_slot = root_param_index;
                ++root_param_index;
            }
        }
        auto &d3d_ele = _elements[kernel_index]._variants[variant_hash];
        auto &sig = d3d_ele._p_sig;
        auto &pso = d3d_ele._pso;

        auto& samplers = CreateStaticSampler();
        D3D12_ROOT_SIGNATURE_FLAGS rootSignatureFlags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
        CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC rootSignatureDesc;
        rootSignatureDesc.Init_1_1(root_param_index, rootParameters, static_cast<u32>(samplers.size()), samplers.data(), rootSignatureFlags);
        ComPtr<ID3DBlob> signature;
        ComPtr<ID3DBlob> error;

        if (SUCCEEDED(D3DX12SerializeVersionedRootSignature(&rootSignatureDesc, featureData.HighestVersion, &signature, &error)) &&
            SUCCEEDED(device->CreateRootSignature(0, signature->GetBufferPointer(), signature->GetBufferSize(), IID_PPV_ARGS(&sig))))
        {
            D3D12_COMPUTE_PIPELINE_STATE_DESC pso_desc{};
            pso_desc.pRootSignature = sig.Get();
            pso_desc.CS = {d3d_ele._p_blob->GetBufferPointer(), d3d_ele._p_blob->GetBufferSize()};
            pso_desc.Flags = D3D12_PIPELINE_STATE_FLAG_NONE;
            if (SUCCEEDED(device->CreateComputePipelineState(&pso_desc, IID_PPV_ARGS(&pso))))
            {
                std::unordered_map<String, ShaderBindResourceInfo> cbuffer_bind_info;
                u32 cbuffer_size = 0;
                u16 cbuffer_count = 0;
                for (auto it = cs_ele._temp_bind_res_infos.begin(); it != cs_ele._temp_bind_res_infos.end(); it++)
                {
                    //临时方案，kCBufNameSceneState外部创建
                    if (it->second._res_type & EBindResDescType::kCBufferAttribute && it->second._p_root_cbuf->_name != RenderConstants::kCBufNamePerScene && it->second._p_root_cbuf->_name != RenderConstants::kCBufNamePerCamera)
                    {
                        cbuffer_bind_info.insert(std::make_pair(it->first, it->second));
                        if (it->second._res_type & EBindResDescType::kCBufferAttribute)
                            cbuffer_size += ShaderBindResourceInfo::GetVariableSize(it->second);
                    }
                }
                AL_ASSERT_MSG(cbuffer_size <= 256, "ComputeBuffer size must be less than 256");
                cbuffer_size = ALIGN_TO_256(cbuffer_size);
                //这里暂时只支持一个cbuffer，以后按需修改
                auto cbuf_it = std::find_if(cs_ele._temp_bind_res_infos.begin(), cs_ele._temp_bind_res_infos.end(), [this](auto it)
                                            {
					auto& desc = it.second;
					return desc._res_type == EBindResDescType::kConstBuffer; });
                if (cbuf_it != cs_ele._temp_bind_res_infos.end())
                {
                    u8 data[256];
                    for (auto it = cbuffer_bind_info.begin(); it != cbuffer_bind_info.end(); it++)
                    {
                        auto old_variable_it = cs_ele._bind_res_infos.find(it->first);
                        if (old_variable_it != cs_ele._bind_res_infos.end())
                        {
                            memcpy(data, _cbuf_data + ShaderBindResourceInfo::GetVariableOffset(old_variable_it->second),
                                   ShaderBindResourceInfo::GetVariableSize(it->second));
                        }
                        memcpy(_cbuf_data, data, 256);
                    }
                    // if (_p_cbuffer == nullptr)
                    // {
                    //     //_p_cbuffer.reset(IConstantBuffer::Create(cbuffer_size, true));
                    // }
                    // else
                    // {
                    //     u8 *data = new u8[cbuffer_size];
                    //     for (auto it = cbuffer_bind_info.begin(); it != cbuffer_bind_info.end(); it++)
                    //     {
                    //         auto old_variable_it = cs_ele._bind_res_infos.find(it->first);
                    //         if (old_variable_it != cs_ele._bind_res_infos.end())
                    //         {
                    //             memcpy(data + ShaderBindResourceInfo::GetVariableOffset(it->second), _p_cbuffer->GetData() + ShaderBindResourceInfo::GetVariableOffset(old_variable_it->second),
                    //                    ShaderBindResourceInfo::GetVariableSize(it->second));
                    //         }
                    //     }
                    //    //memcpy(_p_cbuffer->GetData(), data, cbuffer_size);
                    //     memcpy(_cbuf_data, data, cbuffer_size);
                    //     DESTORY_PTRARR(data);
                    // }
                    // cbuf_it->second._p_res = _p_cbuffer.get();
                }
                cs_ele._bind_res_infos = std::move(cs_ele._temp_bind_res_infos);
                _is_valid = true;
            }
            else
                _is_valid = false;
        }
        else
        {
            _is_valid = false;
            LOG_ERROR(L"Create compute shader {} failed when generate internal pso!", _src_file_path);
        }
    }
    u16 D3DComputeShader::NameToSlot(const String &name, u16 kernel,ShaderVariantHash variant_hash) const
    {
        AL_ASSERT(kernel < _kernels.size());
        if (auto it = _kernels[kernel]._variants.at(variant_hash)._bind_res_infos.find(name); it != _kernels[kernel]._variants.at(variant_hash)._bind_res_infos.end())
            return it->second._bind_slot;
        return INT16_MAX;
    }
#pragma endregion
    //-------------------------------------------------------------------------------D3DComputeShader---------------------------------------------------------------------------
}// namespace Ailu
#include "pch.h"
#include <d3dcompiler.h>
#include <dxcapi.h>
#include <atlcomcli.h>

#include "RHI/DX12/D3DShader.h"
#include "RHI/DX12/dxhelper.h"
#include "Framework/Common/Utils.h"
#include "RHI/DX12/D3DContext.h"
#include "Framework/Common/Utils.h"
#include "RHI/DX12/D3DConstants.h"


namespace Ailu
{
	static uint32_t GetPerFramePropertyOffset(std::string_view name)
	{
		if (name == "_MatrixV")
			return 0;
		else if (name == "_MatrixVP")
			return 64;
		else if (name == "_Color")
			return D3DConstants::kPerFrameDataSize;
	}

	static bool CreateFromFileDXC(const std::wstring& filename, const std::wstring& entryPoint, const std::wstring& pTarget, ComPtr<ID3DBlob>& p_blob,
		ComPtr<ID3D12ShaderReflection>& shader_reflection)
	{
		CComPtr<IDxcUtils> pUtils;
		CComPtr<IDxcCompiler3> pCompiler;
		DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(&pUtils));
		DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&pCompiler));

		CComPtr<IDxcIncludeHandler> pIncludeHandler;
		pUtils->CreateDefaultIncludeHandler(&pIncludeHandler);

		LOG_INFO(filename.c_str());
		LOG_INFO(entryPoint.c_str());
		LOG_INFO(pTarget.c_str());

		LPCWSTR pszArgs[] =
		{
			filename.c_str(),            // Optional shader source file name for error reporting and for PIX shader source view.  
			L"-E", entryPoint.c_str(),              // Entry point.
			L"-T", pTarget.c_str(),            // Target.
			L"-Zi",                      // Enable debug information.
			L"-D", L"MYDEFINE=1",        // A single define.
			L"-Fo", L"myshader.bin",     // Optional. Stored in the pdb. 
			L"-Fd", L"myshader.pdb",     // The file name of the pdb. This must either be supplied or the autogenerated file name must be used.
			L"-Qstrip_reflect",          // Strip reflection into a separate blob. 
		};


		CComPtr<IDxcBlobEncoding> pSource = nullptr;
		pUtils->LoadFile(filename.c_str(), nullptr, &pSource);
		DxcBuffer Source;
		Source.Ptr = pSource->GetBufferPointer();
		Source.Size = pSource->GetBufferSize();
		Source.Encoding = DXC_CP_ACP; // Assume BOM says UTF8 or UTF16 or this is ANSI text.

		//
		// Compile it with specified arguments.
		//
		CComPtr<IDxcResult> pResults;
		pCompiler->Compile(
			&Source,                // Source buffer.
			pszArgs,                // Array of pointers to arguments.
			_countof(pszArgs),      // Number of arguments.
			pIncludeHandler,        // User-provided interface to handle #include directives (optional).
			IID_PPV_ARGS(&pResults) // Compiler output status, buffer, and errors.
		);

		//
		// Print errors if present.
		//
		CComPtr<IDxcBlobUtf8> pErrors = nullptr;
		pResults->GetOutput(DXC_OUT_ERRORS, IID_PPV_ARGS(&pErrors), nullptr);
		// Note that d3dcompiler would return null if no errors or warnings are present.  
		// IDxcCompiler3::Compile will always return an error buffer, but its length will be zero if there are no warnings or errors.
		if (pErrors != nullptr && pErrors->GetStringLength() != 0)
			LOG_ERROR("{}", pErrors->GetStringPointer());

		//
		// Quit if the compilation failed.
		//
		HRESULT hrStatus;
		pResults->GetStatus(&hrStatus);
		if (FAILED(hrStatus))
		{
			LOG_ERROR("Compilation Failed");
			return false;
		}

		//
		// Save shader binary.
		//
		CComPtr<IDxcBlob> pShader = nullptr;
		CComPtr<IDxcBlobUtf16> pShaderName = nullptr;
		pResults->GetOutput(DXC_OUT_OBJECT, IID_PPV_ARGS(&p_blob), &pShaderName);

		CComPtr<IDxcBlob> pReflectionData;
		pResults->GetOutput(DXC_OUT_REFLECTION, IID_PPV_ARGS(&pReflectionData), nullptr);
		if (pReflectionData != nullptr)
		{
			// Optionally, save reflection blob for later here.

			// Create reflection interface.
			DxcBuffer ReflectionData;
			ReflectionData.Encoding = DXC_CP_ACP;
			ReflectionData.Ptr = pReflectionData->GetBufferPointer();
			ReflectionData.Size = pReflectionData->GetBufferSize();
			pUtils->CreateReflection(&ReflectionData, IID_PPV_ARGS(shader_reflection.GetAddressOf()));
		}
		return true;
	}

	static void LoadShaderRelfection(ID3D12ShaderReflection* reflection)
	{
		D3D12_SHADER_DESC desc{};
		reflection->GetDesc(&desc);
		std::vector<D3D12_SIGNATURE_PARAMETER_DESC> inputparams(desc.InputParameters);
		for (size_t i = 0; i < desc.InputParameters; i++)
		{
			auto inputparam_desc = reflection->GetInputParameterDesc(i,&inputparams[i]);
		}
		std::vector<D3D12_SHADER_INPUT_BIND_DESC> bind_desc(desc.BoundResources);
		for (size_t i = 0; i < desc.BoundResources; i++)
		{
			auto resc_desc = reflection->GetResourceBindingDesc(i, &bind_desc[i]);
			if (bind_desc[i].Type == D3D_SHADER_INPUT_TYPE::D3D_SIT_CBUFFER)
			{

			}
		}
		for (size_t i = 0; i < desc.ConstantBuffers; i++)
		{
			auto cbuf = reflection->GetConstantBufferByIndex(i);
			D3D12_SHADER_BUFFER_DESC desc{};
			cbuf->GetDesc(&desc);
			for (size_t j = 0; j < desc.Variables; j++)
			{
				auto variable = cbuf->GetVariableByIndex(j);
				D3D12_SHADER_VARIABLE_DESC vdesc{};
				variable->GetDesc(&vdesc);
				LOG_INFO("{}", vdesc.Name);
			}
		}
			
	}

	D3DShader::D3DShader(const std::string_view file_name, EShaderType type)
	{		
		if (!_b_init_buffer)
		{
			auto device = D3DContext::GetInstance()->GetDevice();
			//constbuffer desc heap
			D3D12_DESCRIPTOR_HEAP_DESC cbvHeapDesc = {};
			cbvHeapDesc.NumDescriptors = (1u + D3DConstants::kMaxMaterialDataCount + D3DConstants::kMaxRenderObjectCount) * D3DConstants::kFrameCount;
			cbvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
			cbvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
			ThrowIfFailed(device->CreateDescriptorHeap(&cbvHeapDesc, IID_PPV_ARGS(&m_cbvHeap)));
			_desc_size = device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
			//constbuffer
			auto heap_prop = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
			auto res_desc = CD3DX12_RESOURCE_DESC::Buffer(D3DConstants::kPerFrameTotalSize * D3DConstants::kFrameCount);
			ThrowIfFailed(device->CreateCommittedResource(&heap_prop,D3D12_HEAP_FLAG_NONE,&res_desc,D3D12_RESOURCE_STATE_GENERIC_READ,nullptr,IID_PPV_ARGS(&m_constantBuffer)));
			// Describe and create a constant buffer view.
			for (uint32_t i = 0; i < D3DConstants::kFrameCount; i++)
			{
				D3D12_CPU_DESCRIPTOR_HANDLE cbvHandle;
				cbvHandle.ptr = m_cbvHeap->GetCPUDescriptorHandleForHeapStart().ptr + i * (1 + D3DConstants::kMaxMaterialDataCount + D3DConstants::kMaxRenderObjectCount) * _desc_size;
				D3D12_CONSTANT_BUFFER_VIEW_DESC cbv_desc = {};
				cbv_desc.BufferLocation = m_constantBuffer->GetGPUVirtualAddress() + i * D3DConstants::kPerFrameTotalSize;
				cbv_desc.SizeInBytes = D3DConstants::kPerFrameDataSize;
				device->CreateConstantBufferView(&cbv_desc, cbvHandle);

				for (uint32_t j = 0; j < D3DConstants::kMaxMaterialDataCount; j++)
				{
					D3D12_CPU_DESCRIPTOR_HANDLE cbvHandle2;
					cbvHandle2.ptr = cbvHandle.ptr + (j + 1) * _desc_size;
					cbv_desc.BufferLocation = m_constantBuffer->GetGPUVirtualAddress() + i *  D3DConstants::kPerFrameTotalSize + D3DConstants::kPerFrameDataSize + j * D3DConstants::kPerMaterialDataSize;
					cbv_desc.SizeInBytes = D3DConstants::kPerMaterialDataSize;
					device->CreateConstantBufferView(&cbv_desc, cbvHandle2);
				}
				for (uint32_t k = 0; k < D3DConstants::kMaxRenderObjectCount; k++)
				{
					D3D12_CPU_DESCRIPTOR_HANDLE cbvHandle2;
					cbvHandle2.ptr = cbvHandle.ptr + (D3DConstants::kMaxMaterialDataCount + 1) * _desc_size;
					cbv_desc.BufferLocation = m_constantBuffer->GetGPUVirtualAddress() + D3DConstants::kPerFrameTotalSize * i + D3DConstants::kPerFrameDataSize + 
						D3DConstants::kMaxMaterialDataCount * D3DConstants::kPerMaterialDataSize + k * D3DConstants::kPeObjectDataSize;
					cbv_desc.SizeInBytes = D3DConstants::kPeObjectDataSize;
					device->CreateConstantBufferView(&cbv_desc, cbvHandle2);
				}
			}
			// Map and initialize the constant buffer. We don't unmap this until the
			// app closes. Keeping things mapped for the lifetime of the resource is okay.
			CD3DX12_RANGE readRange(0, 0);        // We do not intend to read from this resource on the CPU.
			ThrowIfFailed(m_constantBuffer->Map(0, &readRange, reinterpret_cast<void**>(&_p_cbuffer)));
			_b_init_buffer = true;
		}
#if defined(_DEBUG)
		// Enable better shader debugging with the graphics debugging tools.
		UINT compileFlags = D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION;
#else
		UINT compileFlags = 0;
#endif         
		if (type == EShaderType::kVertex)
		{
			//ThrowIfFailed(D3DCompileFromFile(ToWChar(file_name.data()), nullptr, nullptr, "VSMain", "vs_5_0", compileFlags, 0, _p_blob.GetAddressOf(), nullptr));
			D3D12_SHADER_DESC vs_desc;

			CComPtr<IDxcBlob> vs_plob;
			CreateFromFileDXC(ToWChar(file_name.data()), L"VSMain", D3DConstants::kVSModel_6_1, _p_blob, _p_reflection);
			//ThrowIfFailed(vs_plob->QueryInterface(IID_PPV_ARGS(_p_blob.GetAddressOf())));
			LoadShaderRelfection(_p_reflection.Get());
		}
		else if (type == EShaderType::kPixel)
		{
			//ThrowIfFailed(D3DCompileFromFile(ToWChar(file_name.data()), nullptr, nullptr, "PSMain", "ps_5_0", compileFlags, 0, _p_blob.GetAddressOf(), nullptr));
			D3D12_SHADER_DESC ps_desc;
			CComPtr<IDxcBlob> ps_plob;
			CreateFromFileDXC(ToWChar(file_name.data()), L"PSMain", D3DConstants::kPSModel_6_1, _p_blob, _p_reflection);
		}

		{
			D3D12_FEATURE_DATA_ROOT_SIGNATURE featureData = {};

			// This is the highest version the sample supports. If CheckFeatureSupport succeeds, the HighestVersion returned will not be greater than this.
			featureData.HighestVersion = D3D_ROOT_SIGNATURE_VERSION_1_1;
			auto device = D3DContext::GetInstance()->GetDevice();
			if (FAILED(device->CheckFeatureSupport(D3D12_FEATURE_ROOT_SIGNATURE, &featureData, sizeof(featureData))))
			{
				featureData.HighestVersion = D3D_ROOT_SIGNATURE_VERSION_1_0;
			}

			CD3DX12_DESCRIPTOR_RANGE1 ranges[2]{};
			CD3DX12_ROOT_PARAMETER1 rootParameters[2]{};

			ranges[0].Init(D3D12_DESCRIPTOR_RANGE_TYPE_CBV, 1, 0, 0, D3D12_DESCRIPTOR_RANGE_FLAG_DATA_STATIC);
			rootParameters[0].InitAsDescriptorTable(1, &ranges[0], D3D12_SHADER_VISIBILITY_VERTEX);

			ranges[1].Init(D3D12_DESCRIPTOR_RANGE_TYPE_CBV, 1, 1, 0, D3D12_DESCRIPTOR_RANGE_FLAG_DATA_STATIC);
			rootParameters[1].InitAsDescriptorTable(1, &ranges[1], D3D12_SHADER_VISIBILITY_PIXEL);

			// Allow input layout and deny uneccessary access to certain pipeline stages.
			D3D12_ROOT_SIGNATURE_FLAGS rootSignatureFlags =
				D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |
				D3D12_ROOT_SIGNATURE_FLAG_DENY_HULL_SHADER_ROOT_ACCESS |
				D3D12_ROOT_SIGNATURE_FLAG_DENY_DOMAIN_SHADER_ROOT_ACCESS |
				D3D12_ROOT_SIGNATURE_FLAG_DENY_GEOMETRY_SHADER_ROOT_ACCESS;

			CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC rootSignatureDesc;
			rootSignatureDesc.Init_1_1(_countof(rootParameters), rootParameters, 0, nullptr, rootSignatureFlags);

			ComPtr<ID3DBlob> signature;
			ComPtr<ID3DBlob> error;
			ThrowIfFailed(D3DX12SerializeVersionedRootSignature(&rootSignatureDesc, featureData.HighestVersion, &signature, &error));
			ThrowIfFailed(device->CreateRootSignature(0, signature->GetBufferPointer(), signature->GetBufferSize(), IID_PPV_ARGS(_p_sig.GetAddressOf())));
		}
	}
	D3DShader::~D3DShader()
	{
	}

	void* D3DShader::GetByteCode()
	{
		return reinterpret_cast<void*>(_p_blob.Get());
	}

	uint8_t* D3DShader::GetCBufferPtr(uint32_t index)
	{
		return _p_cbuffer + D3DConstants::kPerFrameDataSize + index * D3DConstants::kPerMaterialDataSize;
	}

	void D3DShader::Bind()
	{
		auto cmdlist = D3DContext::GetInstance()->GetCmdList();
		cmdlist->SetGraphicsRootSignature(_p_sig.Get());
		ID3D12DescriptorHeap* ppHeaps[] = { m_cbvHeap.Get() };
		cmdlist->SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);
		cmdlist->SetGraphicsRootDescriptorTable(0, m_cbvHeap->GetGPUDescriptorHandleForHeapStart());
		D3D12_GPU_DESCRIPTOR_HANDLE matHandle;
		matHandle.ptr = m_cbvHeap->GetGPUDescriptorHandleForHeapStart().ptr + _desc_size;	
		cmdlist->SetGraphicsRootDescriptorTable(1, matHandle);
	}

	void D3DShader::Bind(uint32_t index)
	{
		if (index > D3DConstants::kMaxMaterialDataCount)
		{
			AL_ASSERT(true, "Material num more than MaxMaterialDataCount!");
			return;
		}
		auto cmdlist = D3DContext::GetInstance()->GetCmdList();
		cmdlist->SetGraphicsRootSignature(_p_sig.Get());
		ID3D12DescriptorHeap* ppHeaps[] = { m_cbvHeap.Get() };
		cmdlist->SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);
		cmdlist->SetGraphicsRootDescriptorTable(0, m_cbvHeap->GetGPUDescriptorHandleForHeapStart());
		D3D12_GPU_DESCRIPTOR_HANDLE matHandle;
		matHandle.ptr = m_cbvHeap->GetGPUDescriptorHandleForHeapStart().ptr + _desc_size + _desc_size * index;
		cmdlist->SetGraphicsRootDescriptorTable(1, matHandle);
	}

	void D3DShader::SetGlobalVector(const std::string_view name, const Vector4f& vector)
	{
		memcpy(_p_cbuffer + GetPerFramePropertyOffset(name), &vector, sizeof(vector));
	}

	void D3DShader::SetGlobalVector(const std::string_view name, const Vector3f& vector)
	{
	}

	void D3DShader::SetGlobalVector(const std::string_view name, const Vector2f& vector)
	{
	}

	void D3DShader::SetGlobalMatrix(const std::string_view name, const Matrix4x4f& mat)
	{
		memcpy(_p_cbuffer + GetPerFramePropertyOffset(name), &mat, sizeof(mat));
	}
	void D3DShader::SetGlobalMatrix(const std::string_view name, const Matrix3x3f& mat)
	{
	}

	ComPtr<ID3D12RootSignature> D3DShader::GetSignature() const
	{
		return _p_sig;
	}
}

#include "pch.h"
#include <atlcomcli.h>
#include <d3dcompiler.h>
#include <dxcapi.h>

#include "Framework/Common/LogMgr.h"
#include "Framework/Common/Utils.h"
#include "GlobalMarco.h"
#include "RHI/DX12/D3DContext.h"
#include "RHI/DX12/D3DShader.h"
#include "RHI/DX12/dxhelper.h"
#include "RHI/DX12/D3DTexture.h"
#include "RHI/DX12/D3DCommandBuffer.h"
#include "Render/GraphicsPipelineStateObject.h"



namespace Ailu
{
	//shader model 6.0 and higher,can't see cbuffer info in PIX!!!!
	static bool CreateFromFileDXC(const std::wstring& filename, const std::wstring& entryPoint, const std::wstring& pTarget, ComPtr<ID3DBlob>& p_blob,
		ComPtr<ID3D12ShaderReflection>& shader_reflection)
	{
		CComPtr<IDxcUtils> pUtils;
		CComPtr<IDxcCompiler3> pCompiler;
		DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(&pUtils));
		DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&pCompiler));

		CComPtr<IDxcIncludeHandler> pIncludeHandler;
		pUtils->CreateDefaultIncludeHandler(&pIncludeHandler);

		LOG_INFO(filename.c_str());
		LOG_INFO(entryPoint.c_str());
		LOG_INFO(pTarget.c_str());

		LPCWSTR pszArgs[] =
		{
			filename.c_str(),            // Optional shader source file name for error reporting and for PIX shader source view.  
			L"-E", entryPoint.c_str(),              // Entry point.
			L"-T", pTarget.c_str(),            // Target.
			L"-Zi",                      // Enable debug information.
			L"-D", L"MYDEFINE=1",        // A single define.
			L"-Fo", L"myshader.bin",     // Optional. Stored in the pdb. 
			L"-Fd", L"myshader.pdb",     // The file name of the pdb. This must either be supplied or the autogenerated file name must be used.
			L"-Qstrip_reflect",          // Strip reflection into a separate blob. 
		};


		CComPtr<IDxcBlobEncoding> pSource = nullptr;
		pUtils->LoadFile(filename.c_str(), nullptr, &pSource);
		DxcBuffer Source;
		Source.Ptr = pSource->GetBufferPointer();
		Source.Size = pSource->GetBufferSize();
		Source.Encoding = DXC_CP_ACP; // Assume BOM says UTF8 or UTF16 or this is ANSI text.

		//
		// Compile it with specified arguments.
		//
		CComPtr<IDxcResult> pResults;
		pCompiler->Compile(
			&Source,                // Source buffer.
			pszArgs,                // Array of pointers to arguments.
			_countof(pszArgs),      // Number of arguments.
			pIncludeHandler,        // User-provided interface to handle #include directives (optional).
			IID_PPV_ARGS(&pResults) // Compiler output status, buffer, and errors.
		);

		//
		// Print errors if present.
		//
		CComPtr<IDxcBlobUtf8> pErrors = nullptr;
		pResults->GetOutput(DXC_OUT_ERRORS, IID_PPV_ARGS(&pErrors), nullptr);
		// Note that d3dcompiler would return null if no errors or warnings are present.  
		// IDxcCompiler3::Compile will always return an error buffer, but its length will be zero if there are no warnings or errors.
		if (pErrors != nullptr && pErrors->GetStringLength() != 0)
			LOG_ERROR("{}", pErrors->GetStringPointer());

		//
		// Quit if the compilation failed.
		//
		HRESULT hrStatus;
		pResults->GetStatus(&hrStatus);
		if (FAILED(hrStatus))
		{
			LOG_ERROR("Compilation Failed");
			return false;
		}

		//
		// Save shader binary.
		//
		CComPtr<IDxcBlob> pShader = nullptr;
		CComPtr<IDxcBlobUtf16> pShaderName = nullptr;
		pResults->GetOutput(DXC_OUT_OBJECT, IID_PPV_ARGS(&p_blob), &pShaderName);

		CComPtr<IDxcBlob> pReflectionData;
		pResults->GetOutput(DXC_OUT_REFLECTION, IID_PPV_ARGS(&pReflectionData), nullptr);
		if (pReflectionData != nullptr)
		{
			// Optionally, save reflection blob for later here.

			// Create reflection interface.
			DxcBuffer ReflectionData;
			ReflectionData.Encoding = DXC_CP_ACP;
			ReflectionData.Ptr = pReflectionData->GetBufferPointer();
			ReflectionData.Size = pReflectionData->GetBufferSize();
			pUtils->CreateReflection(&ReflectionData, IID_PPV_ARGS(shader_reflection.GetAddressOf()));
		}
		return true;
	}

	static bool CreateFromFileFXC(const std::wstring& filename, const std::string& entryPoint, const std::string& pTarget, ComPtr<ID3DBlob>& p_blob,
		ComPtr<ID3D12ShaderReflection>& shader_reflection)
	{
		ID3DBlob* pErrorBlob = nullptr;
		D3D_SHADER_MACRO macros[] = { {"TEST","0"},{NULL,NULL} };
		UINT compileFlags = 0;
#if defined(_DEBUG)
		// Enable better shader debugging with the graphics debugging tools.
		compileFlags = D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION;
#else
		compileFlags = 0;
#endif
		D3DCompileFromFile(filename.c_str(), macros, D3D_COMPILE_STANDARD_FILE_INCLUDE, entryPoint.c_str(), pTarget.c_str(), compileFlags, 0, &p_blob, &pErrorBlob);
		if (pErrorBlob)
		{
			//OutputDebugStringA(reinterpret_cast<const char*>(pErrorBlob->GetBufferPointer()));
			String text(reinterpret_cast<const char*>(pErrorBlob->GetBufferPointer()));
			// 使用 std::stringstream 分割文本并提取每一行
			std::istringstream iss(text);
			//std::vector<std::string> lines;
			std::string line;
			while (std::getline(iss, line)) 
			{
				if(line.find("error") != line.npos)
					LOG_WARNING("{}", line)
			}
			pErrorBlob->Release();
		}
		if (p_blob != nullptr)
		{
			ID3D12ShaderReflection* pReflection = NULL;
			D3DReflect(p_blob->GetBufferPointer(), p_blob->GetBufferSize(), IID_ID3D12ShaderReflection, (void**)&shader_reflection);
			return true;
		}
		return false;
	}

	static D3D12_PRIMITIVE_TOPOLOGY ConvertTopologyToType(D3D12_PRIMITIVE_TOPOLOGY_TYPE type)
	{
		switch (type)
		{
		case D3D12_PRIMITIVE_TOPOLOGY_TYPE::D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE:
			return D3D12_PRIMITIVE_TOPOLOGY::D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST;
		case D3D12_PRIMITIVE_TOPOLOGY_TYPE::D3D12_PRIMITIVE_TOPOLOGY_TYPE_LINE:
			return D3D12_PRIMITIVE_TOPOLOGY::D3D10_PRIMITIVE_TOPOLOGY_LINELIST;
		default:
			return D3D12_PRIMITIVE_TOPOLOGY::D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST;
		}
		return D3D12_PRIMITIVE_TOPOLOGY::D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST;
	}

	static EShaderDateType GetShaderDataType(const char* semantic)
	{
		if (!std::strcmp(semantic, RenderConstants::kSemanticPosition)) return EShaderDateType::kFloat3;
		else if (!std::strcmp(semantic, RenderConstants::kSemanticNormal)) return EShaderDateType::kFloat3;
		else if (!std::strcmp(semantic, RenderConstants::kSemanticTangent)) return EShaderDateType::kFloat4;
		else if (!std::strcmp(semantic, RenderConstants::kSemanticColor)) return EShaderDateType::kFloat4;
		else if (!std::strcmp(semantic, RenderConstants::kSemanticTexcoord)) return EShaderDateType::kFloat2;
		else if (!std::strcmp(semantic, RenderConstants::kSemanticBoneWeight)) return EShaderDateType::kFloat4;
		else if (!std::strcmp(semantic, RenderConstants::kSemanticBoneIndex)) return EShaderDateType::kuInt4;
		else
		{
			AL_ASSERT(true, "Unsupported DXGI_FORMAT to ShaderDataType!")
				//LOG_ERROR("Unsupported DXGI_FORMAT to ShaderDataType!");
				return EShaderDateType::kBool;
		}
	}

	static EShaderDateType GetShaderDataType(DXGI_FORMAT dx_format)
	{
		switch (dx_format)
		{
		case DXGI_FORMAT_R32G32B32_FLOAT: return EShaderDateType::kFloat3;
		case DXGI_FORMAT_R32G32B32A32_FLOAT: return EShaderDateType::kFloat4;
		case DXGI_FORMAT_R32G32_FLOAT: return EShaderDateType::kFloat2;
		}
		AL_ASSERT(true, "Unsupported DXGI_FORMAT to ShaderDataType!")
			//LOG_ERROR("Unsupported DXGI_FORMAT to ShaderDataType!");
			return EShaderDateType::kBool;
	}

	static const Vector<CD3DX12_STATIC_SAMPLER_DESC>& CreateStaticSampler()
	{
		static Vector<CD3DX12_STATIC_SAMPLER_DESC> samplers{
		CD3DX12_STATIC_SAMPLER_DESC(0,D3D12_FILTER_MIN_MAG_MIP_LINEAR,D3D12_TEXTURE_ADDRESS_MODE_WRAP,D3D12_TEXTURE_ADDRESS_MODE_WRAP,D3D12_TEXTURE_ADDRESS_MODE_WRAP),
		CD3DX12_STATIC_SAMPLER_DESC(1,D3D12_FILTER_MIN_MAG_MIP_LINEAR,D3D12_TEXTURE_ADDRESS_MODE_CLAMP,D3D12_TEXTURE_ADDRESS_MODE_CLAMP,D3D12_TEXTURE_ADDRESS_MODE_CLAMP),
		CD3DX12_STATIC_SAMPLER_DESC(2,D3D12_FILTER_MIN_MAG_MIP_LINEAR,D3D12_TEXTURE_ADDRESS_MODE_BORDER,D3D12_TEXTURE_ADDRESS_MODE_BORDER,D3D12_TEXTURE_ADDRESS_MODE_BORDER),
		CD3DX12_STATIC_SAMPLER_DESC(3,D3D12_FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT,D3D12_TEXTURE_ADDRESS_MODE_BORDER,D3D12_TEXTURE_ADDRESS_MODE_BORDER,D3D12_TEXTURE_ADDRESS_MODE_BORDER,0.0f,16,D3D12_COMPARISON_FUNC_LESS,D3D12_STATIC_BORDER_COLOR_OPAQUE_BLACK),
		};
		return samplers;
	}

	void D3DShader::GenerateInternalPSO()
	{
		D3D12_FEATURE_DATA_ROOT_SIGNATURE featureData = {};
		featureData.HighestVersion = D3D_ROOT_SIGNATURE_VERSION_1_1;
		auto device = D3DContext::Get()->GetDevice();
		if (FAILED(device->CheckFeatureSupport(D3D12_FEATURE_ROOT_SIGNATURE, &featureData, sizeof(featureData))))
		{
			featureData.HighestVersion = D3D_ROOT_SIGNATURE_VERSION_1_0;
		}
		CD3DX12_DESCRIPTOR_RANGE1 ranges[32]{};
		CD3DX12_ROOT_PARAMETER1 rootParameters[32]{};
		int cbuf_mask = 0, texture_count = 0;
		for (auto it = _bind_res_infos.begin(); it != _bind_res_infos.end(); it++)
		{
			auto& desc = it->second;
			//if (desc._res_type == EBindResDescType::kCBufferAttribute) continue;
			if (desc._res_type == EBindResDescType::kConstBuffer)
			{
				if (desc._name == RenderConstants::kCBufNameSceneObject) cbuf_mask |= 0x01;
				else if (desc._name == RenderConstants::kCBufNameSceneMaterial) cbuf_mask |= 0x02;
				else if (desc._name == RenderConstants::kCBufNameSceneState) cbuf_mask |= 0x04;
				else if (desc._name == RenderConstants::kCBufNameScenePass) cbuf_mask |= 0x08;
			}
		}
		u8 root_param_index = 0;
		if (cbuf_mask & 0x01)
		{
			_bind_res_infos[RenderConstants::kCBufNameSceneObject]._bind_slot = root_param_index;
			rootParameters[root_param_index++].InitAsConstantBufferView(0u);
		}
		if (cbuf_mask & 0x02)
		{
			_bind_res_infos[RenderConstants::kCBufNameSceneMaterial]._bind_slot = root_param_index;
			_per_mat_buf_bind_slot = root_param_index;
			rootParameters[root_param_index++].InitAsConstantBufferView(1u);
		}
		if (cbuf_mask & 0x04)
		{
			_bind_res_infos[RenderConstants::kCBufNameSceneState]._bind_slot = root_param_index;
			_per_frame_buf_bind_slot = root_param_index;
			rootParameters[root_param_index++].InitAsConstantBufferView(2u);
		}
		if (cbuf_mask & 0x08)
		{
			_bind_res_infos[RenderConstants::kCBufNameScenePass]._bind_slot = root_param_index;
			_per_pass_buf_bind_slot = root_param_index;
			rootParameters[root_param_index++].InitAsConstantBufferView(3u);
		}
		for (auto it = _bind_res_infos.begin(); it != _bind_res_infos.end(); it++)
		{
			auto& desc = it->second;
			if (desc._res_type == EBindResDescType::kTexture2D)
			{
				++texture_count;
				ranges[root_param_index].Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, desc._res_slot);
				rootParameters[root_param_index].InitAsDescriptorTable(1, &ranges[root_param_index]);
				desc._bind_slot = root_param_index;
				++root_param_index;
			}
		}
		D3D12_ROOT_SIGNATURE_FLAGS rootSignatureFlags =
			D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |
			D3D12_ROOT_SIGNATURE_FLAG_DENY_HULL_SHADER_ROOT_ACCESS |
			D3D12_ROOT_SIGNATURE_FLAG_DENY_DOMAIN_SHADER_ROOT_ACCESS |
			D3D12_ROOT_SIGNATURE_FLAG_DENY_GEOMETRY_SHADER_ROOT_ACCESS;
		CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC rootSignatureDesc;
		auto samplers = CreateStaticSampler();
		rootSignatureDesc.Init_1_1(root_param_index, rootParameters, static_cast<UINT>(samplers.size()), samplers.data(), rootSignatureFlags);
		ComPtr<ID3DBlob> signature;
		ComPtr<ID3DBlob> error;
		ThrowIfFailed(D3DX12SerializeVersionedRootSignature(&rootSignatureDesc, featureData.HighestVersion, &signature, &error));
		ThrowIfFailed(device->CreateRootSignature(0, signature->GetBufferPointer(), signature->GetBufferSize(), IID_PPV_ARGS(&_p_sig)));
	}

	bool D3DShader::RHICompileImpl()
	{
		bool succeed = true;
		ComPtr<ID3DBlob> _tmp_p_vblob = nullptr;
		ComPtr<ID3DBlob> _tmp_p_pblob = nullptr;
		try
		{
			Reset();
#ifdef SHADER_DXC
			CreateFromFileDXC(ToWChar(file_name.data()), L"VSMain", D3DConstants::kVSModel_6_1, _p_vblob, _p_reflection);
			LoadShaderReflection(_p_reflection.Get());
			CreateFromFileDXC(ToWChar(file_name.data()), L"PSMain", D3DConstants::kPSModel_6_1, _p_pblob, _p_reflection);
			LoadShaderReflection(_p_reflection.Get());
#else
			succeed &= CreateFromFileFXC(ToWChar(_src_file_path.data()), _vert_entry, "vs_5_0", _tmp_p_vblob, _p_v_reflection);
			succeed &= CreateFromFileFXC(ToWChar(_src_file_path.data()), _pixel_entry, "ps_5_0", _tmp_p_pblob, _p_p_reflection);
#endif // SHADER_DXC
		}
		catch (const std::exception&)
		{
			succeed = false;
			g_pLogMgr->LogErrorFormat("Compile shader with src {0} failed!", _src_file_path);
		}
		if (succeed)
		{
			LoadShaderReflection(_p_v_reflection.Get(), _p_p_reflection.Get());
			_p_vblob = _tmp_p_vblob;
			_p_pblob = _tmp_p_pblob;
			GenerateInternalPSO();
		}
		return succeed;
	}

	void D3DShader::LoadAdditionalShaderReflection(const String& sys_path)
	{
		using namespace std;
		namespace su = StringUtils;
		namespace fs = std::filesystem;
		ifstream src(sys_path, ios::in);
		string line;
		vector<string> lines;
		List<String> cur_file_head_files{};
		String parent_path = su::SubStrRange(_src_file_path, 0, _src_file_path.find_last_of("/"));
		while (getline(src, line))
		{
			line = su::Trim(line);
			if (su::BeginWith(line, "#include"))
			{
				size_t path_start = line.find_first_of("\"");
				size_t path_end = line.find_last_of("\"");
				auto head_file = su::SubStrRange(line, path_start + 1, path_end - 1);
				_source_files.insert(parent_path + head_file);
				cur_file_head_files.emplace_back(head_file);
			}
			else if (su::BeginWith(line, "Texture2D"))
			{
				size_t name_begin = line.find_first_of("D") + 1;
				size_t name_end = line.find_first_of(":") - 1;
				String tex_name = line.substr(name_begin, name_end - name_begin);
			}
			else if (su::BeginWith(line, "TextureCube"))
			{
				size_t name_begin = line.find_last_of("e") + 1;
				size_t name_end = line.find_first_of(":") - 1;
				String tex_name = line.substr(name_begin, name_end - name_begin);
				auto it = _bind_res_infos.find(tex_name);
				if (it != _bind_res_infos.end())
				{
					it->second._res_type = EBindResDescType::kCubeMap;
				}
			}
			else if (su::BeginWith(line, "uint"))
			{
				size_t value_name_begin = line.find_first_of("t") + 1;
				size_t value_name_end = line.find_first_of(";");
				String value_name = su::Trim(line.substr(value_name_begin, value_name_end - value_name_begin));
				auto it = _bind_res_infos.find(value_name);
				if (it != _bind_res_infos.end())
				{
					auto& c = it->second;
					it->second._res_type = (EBindResDescType)(EBindResDescType::kCBufferAttribute | EBindResDescType::kCBufferUint);
				}
			}
			lines.emplace_back(line);
		}
		src.close();
		fs::path src_path(sys_path);
		fs::path pwd = src_path.parent_path();
		for (auto& head_file : cur_file_head_files)
		{
			fs::path temp = pwd;
			temp.append(head_file);
			cout << temp.string() << endl;
			LoadAdditionalShaderReflection(temp.string());
		}
	}

	D3DShader::D3DShader(const String& sys_path) : Shader(sys_path)
	{
		_src_file_path = sys_path;
		_source_files.insert(sys_path);
		Compile();
	}

	D3DShader::D3DShader(const String& sys_path, const String& vs_entry, String ps_entry) : Shader(sys_path)
	{
		_vert_entry = vs_entry;
		_pixel_entry = ps_entry;
		_src_file_path = sys_path;
		_source_files.insert(sys_path);
		Compile();
	}

	D3DShader::~D3DShader()
	{
		for (auto p : _keyword_defines)
		{
			DESTORY_PTRARR(p);
		}
	}

	std::pair<D3D12_INPUT_ELEMENT_DESC*, u8> D3DShader::GetVertexInputLayout()
	{
		return std::make_pair(_vertex_input_layout, _vertex_input_num);
	}

	void D3DShader::Reset()
	{
		if (_p_vblob != nullptr) _p_vblob.Reset();
		if (_p_pblob != nullptr) _p_pblob.Reset();
		if (_p_v_reflection != nullptr) _p_v_reflection.Reset();
		if (_p_p_reflection != nullptr) _p_p_reflection.Reset();
		_vertex_input_num = 0u;
		memset(_vertex_input_layout, 0, sizeof(D3D12_INPUT_ELEMENT_DESC) * RenderConstants::kMaxVertexAttrNum);
		_pipeline_topology = ETopology::kTriangle;
	}

	void D3DShader::LoadShaderReflection(ID3D12ShaderReflection* ref_vs, ID3D12ShaderReflection* ref_ps)
	{
		D3D12_SHADER_DESC desc{};
		//parser vs reflecton	
		ref_vs->GetDesc(&desc);
		{
			if (desc.InputParameters > 10)
			{
				AL_ASSERT(true, "LayoutDesc count must less than 10");
				return;
			}
			Vector<VertexBufferLayoutDesc> vb_input_desc{};
			for (u32 i = 0u; i < desc.InputParameters; i++)
			{
				D3D12_SIGNATURE_PARAMETER_DESC input_desc{};
				ref_vs->GetInputParameterDesc(i, &input_desc);
				_vertex_input_layout[i] = D3D12_INPUT_ELEMENT_DESC{ input_desc.SemanticName, 0, GetFormatBySemanticName(input_desc.SemanticName), i, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 };
				++_vertex_input_num;
				vb_input_desc.emplace_back(VertexBufferLayoutDesc(input_desc.SemanticName, GetShaderDataType(input_desc.SemanticName), input_desc.Register));
			}
			_pipeline_input_layout = VertexBufferLayout(vb_input_desc);
			for (u32 i = 0u; i < desc.BoundResources; i++)
			{
				D3D12_SHADER_INPUT_BIND_DESC bind_desc{};
				ref_vs->GetResourceBindingDesc(i, &bind_desc);
				auto res_type = bind_desc.Type;
				if (res_type == D3D_SHADER_INPUT_TYPE::D3D_SIT_CBUFFER)
				{
					_bind_res_infos.insert(std::make_pair(bind_desc.Name, ShaderBindResourceInfo{ EBindResDescType::kConstBuffer,static_cast<uint16_t>(bind_desc.BindPoint),0u,bind_desc.Name }));
				}
				else if (res_type == D3D_SHADER_INPUT_TYPE::D3D_SIT_TEXTURE)
				{
					_bind_res_infos.insert(std::make_pair(bind_desc.Name, ShaderBindResourceInfo{ EBindResDescType::kTexture2D,static_cast<uint16_t>(bind_desc.BindPoint),0u,bind_desc.Name }));
				}
				else if (res_type == D3D_SHADER_INPUT_TYPE::D3D_SIT_SAMPLER)
				{
					_bind_res_infos.insert(std::make_pair(bind_desc.Name, ShaderBindResourceInfo{ EBindResDescType::kSampler,static_cast<uint16_t>(bind_desc.BindPoint),0u,bind_desc.Name }));
				}
			}
			for (u32 i = 0u; i < desc.ConstantBuffers; i++)
			{
				auto cbuf = ref_ps->GetConstantBufferByIndex(i);
				D3D12_SHADER_BUFFER_DESC desc{};
				cbuf->GetDesc(&desc);
				for (u32 j = 0u; j < desc.Variables; j++)
				{
					auto variable = cbuf->GetVariableByIndex(j);
					D3D12_SHADER_VARIABLE_DESC vdesc{};
					variable->GetDesc(&vdesc);
					u16 offset = (u16)vdesc.StartOffset;
					u16 size = (u16)vdesc.Size;
					u32 variable_info = 0u;
					variable_info |= offset;
					variable_info <<= 16;
					variable_info |= size;
					auto value_type = EBindResDescType::kCBufferAttribute;
					if (size == 4) value_type = (EBindResDescType)(EBindResDescType::kCBufferFloat | value_type);
					else if (size == 16) value_type = (EBindResDescType)(EBindResDescType::kCBufferFloat4 | value_type);
					else if (size == 64) value_type = (EBindResDescType)(EBindResDescType::kCBufferMatrix4 | value_type);
					else {}
					auto info = ShaderBindResourceInfo{ value_type,variable_info,0u,vdesc.Name };
					_bind_res_infos.insert(std::make_pair(vdesc.Name, info));
				}
			}
		}
		//parser ps reflecton	
		{
			ref_ps->GetDesc(&desc);
			for (u32 i = 0u; i < desc.BoundResources; i++)
			{
				D3D12_SHADER_INPUT_BIND_DESC bind_desc{};
				ref_ps->GetResourceBindingDesc(i, &bind_desc);
				auto res_type = bind_desc.Type;
				if (res_type == D3D_SHADER_INPUT_TYPE::D3D_SIT_CBUFFER)
				{
					_bind_res_infos.insert(std::make_pair(bind_desc.Name, ShaderBindResourceInfo{ EBindResDescType::kConstBuffer,static_cast<uint16_t>(bind_desc.BindPoint),0u,bind_desc.Name }));
				}
				else if (res_type == D3D_SHADER_INPUT_TYPE::D3D_SIT_TEXTURE)
				{
					_bind_res_infos.insert(std::make_pair(bind_desc.Name, ShaderBindResourceInfo{ EBindResDescType::kTexture2D,static_cast<uint16_t>(bind_desc.BindPoint),0u,bind_desc.Name }));
				}
				else if (res_type == D3D_SHADER_INPUT_TYPE::D3D_SIT_SAMPLER)
				{
					_bind_res_infos.insert(std::make_pair(bind_desc.Name, ShaderBindResourceInfo{ EBindResDescType::kSampler,static_cast<uint16_t>(bind_desc.BindPoint),0u,bind_desc.Name }));
				}
			}
			for (u32 i = 0u; i < desc.ConstantBuffers; i++)
			{
				auto cbuf = ref_ps->GetConstantBufferByIndex(i);
				D3D12_SHADER_BUFFER_DESC desc{};
				cbuf->GetDesc(&desc);
				for (u32 j = 0u; j < desc.Variables; j++)
				{
					auto variable = cbuf->GetVariableByIndex(j);
					D3D12_SHADER_VARIABLE_DESC vdesc{};
					variable->GetDesc(&vdesc);
					u16 offset = (u16)vdesc.StartOffset;
					u16 size = (u16)vdesc.Size;
					u32 variable_info = 0u;
					variable_info |= offset;
					variable_info <<= 16;
					variable_info |= size;
					auto value_type = EBindResDescType::kCBufferAttribute;
					if (size == 4) value_type = (EBindResDescType)(EBindResDescType::kCBufferFloat | value_type);
					else if (size == 16) value_type = (EBindResDescType)(EBindResDescType::kCBufferFloat4 | value_type);
					else if (size == 64) value_type = (EBindResDescType)(EBindResDescType::kCBufferMatrix4 | value_type);
					else {}
					auto info = ShaderBindResourceInfo{ value_type,variable_info,0u,vdesc.Name };
					_bind_res_infos.insert(std::make_pair(vdesc.Name, info));
				}
			}
		}
		//parser additon info
		LoadAdditionalShaderReflection(_src_file_path);
	}

	void D3DShader::Bind(u32 index)
	{
		Shader::Bind(index);
		static auto context = D3DContext::Get();
		if (_per_frame_buf_bind_slot != -1)
		{
			//GraphicsPipelineStateMgr::SubmitBindResource(reinterpret_cast<void*>(context->GetCBufGPURes(0)), EBindResDescType::kConstBuffer, _per_frame_buf_bind_slot);
			GraphicsPipelineStateMgr::SubmitBindResource(s_p_per_frame_cbuffer, EBindResDescType::kConstBuffer, static_cast<u8>(_per_frame_buf_bind_slot));
		}
	}

	void* D3DShader::GetByteCode(EShaderType type)
	{
		switch (type)
		{
		case Ailu::EShaderType::kVertex:
			return reinterpret_cast<void*>(_p_vblob.Get());
		case Ailu::EShaderType::kPixel:
			return reinterpret_cast<void*>(_p_pblob.Get());
		}
		return nullptr;
	}

	ID3D12RootSignature* D3DShader::GetSignature()
	{
		return _p_sig.Get();
	}


	//-------------------------------------------------------------------------------D3DComputeShader---------------------------------------------------------------------------
	D3DComputeShader::D3DComputeShader(const String& sys_path) : ComputeShader(sys_path)
	{
		Compile();
	}

	void D3DComputeShader::Bind(CommandBuffer* cmd,u16 thread_group_x, u16 thread_group_y, u16 thread_group_z)
	{
		if (!_is_valid)
		{
			LOG_WARNING("ComputeShader is not valid!");
			return;
		}
		auto d3dcmd = static_cast<D3DCommandBuffer*>(cmd)->GetCmdList();
		_pso_sys.Bind(d3dcmd);
		for (auto& info : _bind_res_infos)
		{
			auto& bind_info = info.second;
			if (bind_info._p_res != nullptr)
			{
				if (bind_info._res_type == EBindResDescType::kTexture2D)
				{
					d3dcmd->SetComputeRootDescriptorTable(bind_info._bind_slot, static_cast<D3DTexture2D*>(bind_info._p_res)->GetMainGPUSRVHandle());
				}
				else if (bind_info._res_type == EBindResDescType::kUAVTexture2D)
				{
					d3dcmd->SetComputeRootDescriptorTable(bind_info._bind_slot, static_cast<D3DTexture2D*>(bind_info._p_res)->GetMainGPUSRVHandle());
				}
			}
		}
		d3dcmd->Dispatch(thread_group_x, thread_group_y, thread_group_z);
	}


	void D3DComputeShader::LoadReflectionInfo(ID3D12ShaderReflection* p_reflect)
	{
		D3D12_SHADER_DESC desc{};
		_temp_bind_res_infos.clear();
		//parser vs reflecton	
		p_reflect->GetDesc(&desc);
		for (u32 i = 0u; i < desc.BoundResources; i++)
		{
			D3D12_SHADER_INPUT_BIND_DESC bind_desc{};
			p_reflect->GetResourceBindingDesc(i, &bind_desc);
			auto res_type = bind_desc.Type;
			if (res_type == D3D_SHADER_INPUT_TYPE::D3D_SIT_CBUFFER)
			{
				_temp_bind_res_infos.insert(std::make_pair(bind_desc.Name, ShaderBindResourceInfo{ EBindResDescType::kConstBuffer,static_cast<uint16_t>(bind_desc.BindPoint),0u,bind_desc.Name }));
			}
			else if (res_type == D3D_SHADER_INPUT_TYPE::D3D_SIT_TEXTURE)
			{
				_temp_bind_res_infos.insert(std::make_pair(bind_desc.Name, ShaderBindResourceInfo{ EBindResDescType::kTexture2D,static_cast<uint16_t>(bind_desc.BindPoint),0u,bind_desc.Name }));
			}
			else if (res_type == D3D_SHADER_INPUT_TYPE::D3D_SIT_SAMPLER)
			{
				_temp_bind_res_infos.insert(std::make_pair(bind_desc.Name, ShaderBindResourceInfo{ EBindResDescType::kSampler,static_cast<uint16_t>(bind_desc.BindPoint),0u,bind_desc.Name }));
			}
			else if (res_type == D3D_SHADER_INPUT_TYPE::D3D_SIT_UAV_RWTYPED)
			{
				_temp_bind_res_infos.insert(std::make_pair(bind_desc.Name, ShaderBindResourceInfo{ EBindResDescType::kUAVTexture2D,static_cast<uint16_t>(bind_desc.BindPoint),0u,bind_desc.Name }));
			}
		}
	}

	bool D3DComputeShader::RHICompileImpl()
	{
		bool succeed = true;
		ComPtr<ID3DBlob> _tmp_blob = nullptr;
		try
		{
#ifdef SHADER_DXC
			CreateFromFileDXC(ToWChar(file_name.data()), L"VSMain", D3DConstants::kVSModel_6_1, _p_vblob, _p_reflection);
			LoadShaderReflection(_p_reflection.Get());
#else
			succeed &= CreateFromFileFXC(ToWChar(_src_file_path.data()), "cs_main", "cs_5_0", _tmp_blob, _p_reflection);
#endif // SHADER_DXC
		}
		catch (const std::exception&)
		{
			succeed = false;
			g_pLogMgr->LogErrorFormat("Compile shader with src {0} failed!", _src_file_path);
			_is_valid = false;
		}
		if (succeed)
		{
			_p_blob = _tmp_blob;
			LoadReflectionInfo(_p_reflection.Get());
			GenerateInternalPSO();
			succeed = _is_valid;
			LOG_INFO("Compile shader with src {0} succeed!", _src_file_path);
		}
		return succeed;
	}

	void D3DComputeShader::GenerateInternalPSO()
	{
		D3D12_FEATURE_DATA_ROOT_SIGNATURE featureData = {};
		featureData.HighestVersion = D3D_ROOT_SIGNATURE_VERSION_1_1;
		auto device = D3DContext::Get()->GetDevice();
		if (FAILED(device->CheckFeatureSupport(D3D12_FEATURE_ROOT_SIGNATURE, &featureData, sizeof(featureData))))
		{
			featureData.HighestVersion = D3D_ROOT_SIGNATURE_VERSION_1_0;
		}
		CD3DX12_DESCRIPTOR_RANGE1 ranges[32]{};
		CD3DX12_ROOT_PARAMETER1 rootParameters[32]{};
		int texture_count = 0;
		u8 root_param_index = 0;
		for (auto it = _temp_bind_res_infos.begin(); it != _temp_bind_res_infos.end(); it++)
		{
			auto& desc = it->second;
			if (desc._res_type == EBindResDescType::kTexture2D)
			{
				++texture_count;
				ranges[root_param_index].Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, desc._res_slot);
				rootParameters[root_param_index].InitAsDescriptorTable(1, &ranges[root_param_index]);
				desc._bind_slot = root_param_index;
				++root_param_index;
			}
			else if (desc._res_type == EBindResDescType::kUAVTexture2D)
			{
				++texture_count;
				ranges[root_param_index].Init(D3D12_DESCRIPTOR_RANGE_TYPE_UAV, 1, desc._res_slot);
				rootParameters[root_param_index].InitAsDescriptorTable(1, &ranges[root_param_index]);
				desc._bind_slot = root_param_index;
				++root_param_index;
			}
		}
		auto [sig, pso] = _pso_sys.Back();
		static Vector<CD3DX12_STATIC_SAMPLER_DESC> samplers{
			CD3DX12_STATIC_SAMPLER_DESC(0,D3D12_FILTER_MIN_MAG_MIP_LINEAR,D3D12_TEXTURE_ADDRESS_MODE_WRAP,D3D12_TEXTURE_ADDRESS_MODE_WRAP,D3D12_TEXTURE_ADDRESS_MODE_WRAP),
			CD3DX12_STATIC_SAMPLER_DESC(1,D3D12_FILTER_MIN_MAG_MIP_LINEAR,D3D12_TEXTURE_ADDRESS_MODE_CLAMP,D3D12_TEXTURE_ADDRESS_MODE_CLAMP,D3D12_TEXTURE_ADDRESS_MODE_CLAMP),
			CD3DX12_STATIC_SAMPLER_DESC(2,D3D12_FILTER_MIN_MAG_MIP_LINEAR,D3D12_TEXTURE_ADDRESS_MODE_BORDER,D3D12_TEXTURE_ADDRESS_MODE_BORDER,D3D12_TEXTURE_ADDRESS_MODE_BORDER)
		};

		D3D12_ROOT_SIGNATURE_FLAGS rootSignatureFlags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
		CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC rootSignatureDesc;
		rootSignatureDesc.Init_1_1(root_param_index, rootParameters, static_cast<u32>(samplers.size()), samplers.data(), rootSignatureFlags);
		ComPtr<ID3DBlob> signature;
		ComPtr<ID3DBlob> error;

		if (SUCCEEDED(D3DX12SerializeVersionedRootSignature(&rootSignatureDesc, featureData.HighestVersion, &signature, &error)) &&
			SUCCEEDED(device->CreateRootSignature(0, signature->GetBufferPointer(), signature->GetBufferSize(), IID_PPV_ARGS(&sig))))
		{
			D3D12_COMPUTE_PIPELINE_STATE_DESC pso_desc{};
			pso_desc.pRootSignature = sig.Get();
			pso_desc.CS = { _p_blob->GetBufferPointer() ,_p_blob->GetBufferSize() };
			pso_desc.Flags = D3D12_PIPELINE_STATE_FLAG_NONE;
			if (SUCCEEDED(device->CreateComputePipelineState(&pso_desc, IID_PPV_ARGS(&pso))))
			{
				_pso_sys.Swap();
				_bind_res_infos = std::move(_temp_bind_res_infos);
				_is_valid = true;
			}
			else
				_is_valid = false;
		}
		else
		{
			_is_valid = false;
			LOG_ERROR("Create compute shader {} failed when generate internal pso!", _src_file_path);
		}
	
	}

	//-------------------------------------------------------------------------------D3DComputeShader---------------------------------------------------------------------------
}
